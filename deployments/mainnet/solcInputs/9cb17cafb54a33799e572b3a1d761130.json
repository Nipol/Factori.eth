{
  "language": "Solidity",
  "sources": {
    "contracts/FactoryV1.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IERC20.sol\";\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport \"@beandao/contracts/library/Address.sol\";\nimport \"@beandao/contracts/library/BeaconDeployer.sol\";\nimport {Ownership, IERC173} from \"@beandao/contracts/library/Ownership.sol\";\nimport {BeaconProxyDeployer} from \"@beandao/contracts/library/BeaconProxyDeployer.sol\";\nimport {MinimalProxyDeployer} from \"@beandao/contracts/library/MinimalProxyDeployer.sol\";\nimport {Multicall, IMulticall} from \"@beandao/contracts/library/Multicall.sol\";\nimport \"./IFactory.sol\";\n\n/**\n * @title Factory V1\n * @author yoonsung.eth\n * @notice Abstract reusable contract into template and deploy them in small sizes `minimal proxy` and `beacon proxy`.\n * This contract can receive a fee lower than the deploy cost, and registered addresses do not have to pay the fee.\n * Beacon is managed in this contract, it can be useful if you need a scalable upgrade through the `beacon proxy`.\n * @dev The template to be registered may or may not have an `initialize` function.\n * However, at least a ERC173 and multicall for directed at self must be implemented.\n */\ncontract FactoryV1 is Ownership, Multicall, IFactory {\n    using Address for address;\n\n    /**\n     * @notice template key for template info.\n     */\n    mapping(bytes32 => TemplateInfo) public templates;\n\n    /**\n     * @notice registered template for nonce.\n     */\n    mapping(address => uint256) private nonceForTemplate;\n\n    /**\n     * @notice template count.\n     */\n    uint256 public nonce = 1;\n\n    /**\n     * @notice base fee\n     */\n    uint256 public baseFee;\n\n    /**\n     * @notice fee collector\n     */\n    address payable public feeTo;\n\n    /**\n     * @notice requiring on deploy, allowlist contract.\n     * @param feeAmount basic fee for ether amount\n     * @param feeToAddr fee collector address\n     */\n    constructor(uint256 feeAmount, address payable feeToAddr) {\n        baseFee = feeAmount;\n        feeTo = feeToAddr;\n        nonceForTemplate[address(0)] = type(uint256).max;\n    }\n\n    /**\n     * @notice template id를 통해서 minimal proxy와 minimal beacon proxy를 배포하는 함수.\n     * @dev 일반적으로 배포되는 컨트랙트와 같이 컨트랙트가 생성될 때 초기화 함수를 실행해야 한다면, initializationCallData에 호출할 함수를\n     * serialize하여 주입하여야 합니다. 컨트랙트 소유권을 별도로 관리해야하는 경우 multicall을 통해서 명시적인 소유권 이전이 되어야 합니다.\n     * @param templateId 배포할 컨트랙트의 template id\n     * @param isBeacon 비콘으로 배포해야 할 것인지 결정하는 인자.\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     * @param calls 컨트랙트가 배포된 이후, 필요한 일련의 함수 호출 정보\n     */\n    function deploy(\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed) {\n        // 템플릿을 배포하기 위한 수수료가 적정 수준인지 확인.\n        require(baseFee <= msg.value || owner == msg.sender, \"Factory/Incorrect-amounts\");\n        // 수수료 전송\n        feeTransfer(feeTo, msg.value);\n        // 배포할 템플릿의 정보\n        TemplateInfo memory tmp = templates[templateId];\n\n        deployed = isBeacon\n            ? BeaconProxyDeployer.deploy(tmp.btemplate, initializationCallData)\n            : MinimalProxyDeployer.deploy(tmp.template, initializationCallData);\n\n        // 부수적으로 호출할 데이터가 있다면, 배포된 컨트랙트에 추가적인 call을 할 수 있음.\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\n        // 이벤트 호출\n        emit Deployed(deployed, msg.sender);\n    }\n\n    /**\n     * @notice template id와 외부에서 관리되는 seed를 통해서 minimal proxy와 minimal beacon proxy를 배포하는 함수.\n     * @dev 일반적으로 배포되는 컨트랙트와 같이 컨트랙트가 생성될 때 초기화 함수를 실행해야 한다면, initializationCallData에 호출할 함수를\n     * serialize하여 주입하여야 합니다. 컨트랙트 소유권을 별도로 관리해야하는 경우 multicall을 통해서 명시적인 소유권 이전이 되어야 합니다.\n     * @param seed 컨트랙트 주소 확정에 필요한 외부 seed\n     * @param isBeacon 비콘으로 배포해야 할 것인지 결정하는 인자.\n     * @param templateId 배포할 컨트랙트의 template id\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     * @param calls 컨트랙트가 배포된 이후, 필요한 일련의 함수 호출 정보\n     */\n    function deployWithSeed(\n        string memory seed,\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed) {\n        // 템플릿을 배포하기 위한 수수료가 적정 수준인지 확인.\n        require(baseFee <= msg.value || owner == msg.sender, \"Factory/Incorrect-amounts\");\n        // 수수료 전송\n        feeTransfer(feeTo, msg.value);\n        // 배포할 템플릿의 정보\n        TemplateInfo memory tmp = templates[templateId];\n\n        deployed = isBeacon\n            ? BeaconProxyDeployer.deploy(seed, tmp.btemplate, initializationCallData)\n            : MinimalProxyDeployer.deploy(seed, tmp.template, initializationCallData);\n\n        // 부수적으로 호출할 데이터가 있다면, 배포된 컨트랙트에 추가적인 call을 할 수 있음.\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\n        // 이벤트 호출\n        emit Deployed(deployed, msg.sender);\n    }\n\n    /**\n     * @notice template id와 초기화 데이터 통해서 minimal proxy와 minimal beacon proxy로 배포할 주소를 미리 파악하는 함수\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @param isBeacon 비콘으로 배포해야 할 것인지 결정하는 인자.\n     * @param templateId 배포할 컨트랙트의 template id\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     */\n    function compute(\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view returns (address deployable) {\n        TemplateInfo memory tmp = templates[templateId];\n        deployable = isBeacon\n            ? BeaconProxyDeployer.calculateAddress(tmp.btemplate, initializationCallData)\n            : MinimalProxyDeployer.calculateAddress(tmp.template, initializationCallData);\n    }\n\n    /**\n     * @notice template id와 Seed 문자열, 초기화 데이터 통해서 minimal proxy와 minimal beacon proxy로 배포할 주소를 미리 파악하는 함수\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @param seed 컨트랙트에 사용할 seed 문자열\n     * @param isBeacon 비콘으로 배포해야 할 것인지 결정하는 인자.\n     * @param templateId 배포할 컨트랙트의 template id\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     */\n    function computeWithSeed(\n        string memory seed,\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view returns (address deployable) {\n        TemplateInfo memory tmp = templates[templateId];\n        deployable = isBeacon\n            ? BeaconProxyDeployer.calculateAddress(seed, tmp.btemplate, initializationCallData)\n            : MinimalProxyDeployer.calculateAddress(seed, tmp.template, initializationCallData);\n    }\n\n    /**\n     * @notice Factori.eth에 등록되지 않은 컨트랙트를 Template로 하여 Minimal Proxy로 배포합니다.\n     * @param templateAddr 템플릿으로 사용할 이미 배포된 컨트랙트 주소\n     * @param initializationCallData 배포되면서 호출되어야 하는 초기화 함수\n     * @param calls 초기화 함수 이외에, 호출되어야 하는 함수들의 배열\n     */\n    function clone(\n        address templateAddr,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed) {\n        require(nonceForTemplate[templateAddr] == 0, \"Factory/Registered-Template\");\n        // 템플릿을 배포하기 위한 수수료가 적정 수준인지 확인.\n        require(baseFee == msg.value || owner == msg.sender, \"Factory/Incorrect-amounts\");\n        // 수수료 전송\n        feeTransfer(feeTo, msg.value);\n        deployed = MinimalProxyDeployer.deploy(templateAddr, initializationCallData);\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\n    }\n\n    /**\n     * @notice Factori.eth에 등록되지 않은 컨트랙트를 Template로 하여 minimal proxy로 배포할 주소를 미리 파악하는 함수\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @param templateAddr 배포할 컨트랙트의 template id\n     * @param initializationCallData 컨트랙트가 생성될 때 호출할 직렬화된 초기화 함수 정보\n     */\n    function computeClone(address templateAddr, bytes memory initializationCallData)\n        external\n        view\n        returns (address deployable)\n    {\n        deployable = MinimalProxyDeployer.calculateAddress(templateAddr, initializationCallData);\n    }\n\n    /**\n     * @notice template id에 따라서 컨트랙트를 배포하기 위한 필요 가격을 가져오는 함\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @return price 이더리움으로 구성된 값을 가짐.\n     */\n    function getPrice() external view returns (uint256 price) {\n        price = baseFee;\n    }\n\n    /**\n     * @notice 템플릿으로 사용되기 적합한 인터페이스가 구현된 컨트랙트를 템플릿으로 가격과 함께 등록함.\n     * @dev 같은 템플릿이 비콘과, 일반적인 템플릿으로 등록될 수 있습니다. 따라서 선택적으로 사용 가능합니다.\n     * @param templateAddr 템플릿으로 사용될 컨트랙트의 주소\n     */\n    function addTemplate(address templateAddr) external onlyOwner {\n        require(nonceForTemplate[templateAddr] == 0, \"Factory/Non-Valid\");\n        bytes32 key = keccak256(abi.encode(templateAddr, nonce));\n        address beaconAddr = BeaconDeployer.deploy(templateAddr);\n        templates[key] = TemplateInfo({template: templateAddr, btemplate: beaconAddr});\n        nonceForTemplate[templateAddr] = nonce++;\n        emit NewTemplate(key, templateAddr, beaconAddr);\n    }\n\n    /**\n     * @notice 등록된 템플릿의 정보를 변경하는 함수, 비콘인 경우에는 템플릿을 업데이트 할 수 있으나 비콘이 아니라면 업데이트 불가능.\n     * @param key 업데이트 될 템플릿의 아이디\n     * @param templateAddr 비콘일 경우 템플릿 주소, 템플릿 소유주 주소를 순서대로 인코딩\n     */\n    function updateTemplate(bytes32 key, address templateAddr) external onlyOwner {\n        require(templateAddr != address(0), \"Factory/Non-Valid\");\n        require(nonceForTemplate[templateAddr] == 0, \"Factory/registered-before\");\n        require(templateAddr.isContract(), \"Factory/is-not-Contract\");\n        TemplateInfo memory tmp = templates[key];\n        tmp.template = templateAddr;\n        (bool success, ) = tmp.btemplate.call(abi.encode(templateAddr));\n        assert(success);\n        templates[key] = tmp;\n        emit UpdatedTemplate(key, tmp.template);\n    }\n\n    /**\n     * @notice 등록된 템플릿을 삭제하는 함수\n     * @param key 삭제될 템플릿의 아이디\n     */\n    function removeTemplate(bytes32 key) external onlyOwner {\n        TemplateInfo memory tmp = templates[key];\n        require(tmp.template != address(0), \"Factory/Non-Exist\");\n        delete templates[key];\n        emit DeletedTemplate(key);\n    }\n\n    /**\n     * @notice 고정 수수료를 변경\n     * @param newFee 변경된 수수료\n     */\n    function changeFee(uint256 newFee) external onlyOwner {\n        uint256 prevFee = baseFee;\n        baseFee = newFee;\n        emit FeeChanged(prevFee, newFee);\n    }\n\n    /**\n     * @notice 수수료를 수취할 대상 변경\n     * @param newFeeTo 수취할 대상 주소\n     */\n    function changeFeeTo(address payable newFeeTo) external onlyOwner {\n        address prevFeeTo = feeTo;\n        feeTo = newFeeTo;\n        emit FeeToChanged(prevFeeTo, newFeeTo);\n    }\n\n    /**\n     * @notice Factori.eth에 쌓여있는 ETH와 토큰을 호출하여, 수수료 수취 주소에 전송함\n     * @param tokenAddr 수취할 토큰 주소\n     */\n    function collect(address tokenAddr) external onlyOwner {\n        IERC20(tokenAddr).transfer(feeTo, IERC20(tokenAddr).balanceOf(address(this)));\n    }\n\n    function recoverOwnership(address deployed, address to) external onlyOwner {\n        IERC173(deployed).transferOwnership(to);\n    }\n\n    function feeTransfer(address to, uint256 amount) internal returns (bool callStatus) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n            let returnDataSize := returndatasize()\n            if iszero(callStatus) {\n                returndatacopy(0, 0, returnDataSize)\n                revert(0, returnDataSize)\n            }\n        }\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function balanceOf(address target) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "@beandao/contracts/interfaces/IERC165.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "@beandao/contracts/library/Address.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n    function isContract(address target) internal view returns (bool result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := gt(extcodesize(target), 0)\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/BeaconDeployer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title BeaconDeployer\n * @author yoonsung.eth\n * @notice library that deploy Beacon contract.\n */\nlibrary BeaconDeployer {\n    function deploy(address implementation) internal returns (address result) {\n        bytes memory code = abi.encodePacked(\n            hex\"606161002960003933600081816002015260310152602080380360803960805160005560616000f3fe337f00000000000000000000000000000000000000000000000000000000000000001415602e57600035600055005b337f00000000000000000000000000000000000000000000000000000000000000001460605760005460005260206000f35b\",\n            abi.encode(implementation)\n        );\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := create(0, add(code, 0x20), mload(code))\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/Ownership.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC173.sol\";\n\n/**\n * @title Ownership\n * @author yoonsung.eth\n * @notice 단일 Ownership을 가질 수 있도록 도와주는 추상 컨트랙트\n * @dev constructor 기반 컨트랙트에서는 생성 시점에 owner가 msg.sender로 지정되며,\n *      Proxy로 작동되는 컨트랙트의 경우 `__transferOwnership(address)`를 명시적으로 호출하여 owner를 지정하여야 한다.\n */\nabstract contract Ownership is IERC173 {\n    address public override owner;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownership/Not-Authorized\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    function transferOwnership(address newOwner) external virtual override onlyOwner {\n        require(newOwner != address(0), \"Ownership/Not-Allowed-Zero\");\n        _transferOwnership(newOwner);\n    }\n\n    function resignOwnership() external virtual onlyOwner {\n        delete owner;\n        emit OwnershipTransferred(msg.sender, address(0));\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        address prev = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(prev, newOwner);\n    }\n}\n"
    },
    "@beandao/contracts/library/BeaconProxyDeployer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./BeaconMaker.sol\";\nimport \"./BeaconMakerWithCall.sol\";\n\n/**\n * @title BeaconProxyDeployer\n * @author yoonsung.eth\n * @notice Beacon Minimal Proxy를 배포하는 기능을 가진 라이브러리\n */\nlibrary BeaconProxyDeployer {\n    function deploy(address beacon, bytes memory initializationCalldata) internal returns (address result) {\n        bytes memory createCode = creation(beacon, initializationCalldata);\n\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(\n        string memory seed,\n        address beacon,\n        bytes memory initializationCalldata\n    ) internal returns (address result) {\n        bytes memory createCode = creation(beacon, initializationCalldata);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(address template, bytes memory initializationCalldata)\n        internal\n        view\n        returns (address addr)\n    {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        (, addr) = getSaltAndTarget(createCode);\n    }\n\n    function calculateAddress(\n        string memory seed,\n        address template,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        addr = getTargetFromSeed(createCode, seed);\n    }\n\n    function isBeacon(address beaconAddr, address target) internal view returns (bool result) {\n        bytes20 beaconAddrBytes = bytes20(beaconAddr);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\n            mstore(add(clone, 0x6), beaconAddrBytes)\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\n\n            let other := add(clone, 0x40)\n            extcodecopy(target, other, 0, 0x3c)\n            result := eq(mload(clone), mload(other))\n        }\n    }\n\n    function getSaltAndTarget(bytes memory initCode) internal view returns (bytes32 salt, address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        // set the initial nonce to be provided when constructing the salt.\n        uint256 nonce = 0;\n\n        // declare variable for code size of derived address.\n        bool exist;\n\n        while (true) {\n            // derive `CREATE2` salt using `msg.sender` and nonce.\n            salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n            target = address( // derive the target deployment address.\n                uint160( // downcast to match the address type.\n                    uint256( // cast to uint to truncate upper digits.\n                        keccak256( // compute CREATE2 hash using 4 inputs.\n                            abi.encodePacked( // pack all inputs to the hash together.\n                                bytes1(0xff), // pass in the control character.\n                                address(this), // pass in the address of this contract.\n                                salt, // pass in the salt from above.\n                                initCodeHash // pass in hash of contract creation code.\n                            )\n                        )\n                    )\n                )\n            );\n\n            // determine if a contract is already deployed to the target address.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                exist := gt(extcodesize(target), 0)\n            }\n\n            // exit the loop if no contract is deployed to the target address.\n            if (!exist) {\n                break;\n            }\n\n            // otherwise, increment the nonce and derive a new salt.\n            nonce++;\n        }\n    }\n\n    function getTargetFromSeed(bytes memory initCode, string memory seed) internal view returns (address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        target = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            address(this), // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function creation(address addr, bytes memory initializationCalldata)\n        private\n        pure\n        returns (bytes memory createCode)\n    {\n        createCode = initializationCalldata.length > 0\n            ? abi.encodePacked(\n                type(BeaconMakerWithCall).creationCode,\n                abi.encode(address(addr), initializationCalldata)\n            )\n            : abi.encodePacked(type(BeaconMaker).creationCode, abi.encode(address(addr)));\n    }\n}\n"
    },
    "@beandao/contracts/library/MinimalProxyDeployer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./MinimalMaker.sol\";\nimport \"./MinimalMakerWithCall.sol\";\n\n/**\n * @title MinimalProxyDeployer\n * @author yoonsung.eth\n * @notice Minimal Proxy를 배포하는 기능을 가진 라이브러리\n */\nlibrary MinimalProxyDeployer {\n    function deploy(address template, bytes memory initializationCalldata) internal returns (address result) {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(\n        string memory seed,\n        address template,\n        bytes memory initializationCalldata\n    ) internal returns (address result) {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(address template, bytes memory initializationCalldata)\n        internal\n        view\n        returns (address addr)\n    {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        (, addr) = getSaltAndTarget(createCode);\n    }\n\n    function calculateAddress(\n        string memory seed,\n        address template,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode = creation(template, initializationCalldata);\n\n        addr = getTargetFromSeed(createCode, seed);\n    }\n\n    function isMinimal(address templateAddr, address target) internal view returns (bool result) {\n        bytes20 templateAddrBytes = bytes20(templateAddr);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), templateAddrBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n            let other := add(clone, 0x40)\n            extcodecopy(target, other, 0, 0x2d)\n            result := eq(mload(clone), mload(other))\n        }\n    }\n\n    function getSaltAndTarget(bytes memory initCode) internal view returns (bytes32 salt, address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        // set the initial nonce to be provided when constructing the salt.\n        uint256 nonce = 0;\n\n        // declare variable for code size of derived address.\n        bool exist;\n\n        while (true) {\n            // derive `CREATE2` salt using `msg.sender` and nonce.\n            salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n            target = address( // derive the target deployment address.\n                uint160( // downcast to match the address type.\n                    uint256( // cast to uint to truncate upper digits.\n                        keccak256( // compute CREATE2 hash using 4 inputs.\n                            abi.encodePacked( // pack all inputs to the hash together.\n                                bytes1(0xff), // pass in the control character.\n                                address(this), // pass in the address of this contract.\n                                salt, // pass in the salt from above.\n                                initCodeHash // pass in hash of contract creation code.\n                            )\n                        )\n                    )\n                )\n            );\n\n            // determine if a contract is already deployed to the target address.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                exist := gt(extcodesize(target), 0)\n            }\n\n            // exit the loop if no contract is deployed to the target address.\n            if (!exist) {\n                break;\n            }\n\n            // otherwise, increment the nonce and derive a new salt.\n            nonce++;\n        }\n    }\n\n    function getTargetFromSeed(bytes memory initCode, string memory seed) internal view returns (address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        target = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            address(this), // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    function creation(address addr, bytes memory initializationCalldata)\n        private\n        pure\n        returns (bytes memory createCode)\n    {\n        createCode = initializationCalldata.length > 0\n            ? abi.encodePacked(\n                type(MinimalMakerWithCall).creationCode,\n                abi.encode(address(addr), initializationCalldata)\n            )\n            : abi.encodePacked(type(MinimalMaker).creationCode, abi.encode(address(addr)));\n    }\n}\n"
    },
    "@beandao/contracts/library/Multicall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMulticall.sol\";\n\n/**\n * @title Multicall\n * @author yoonsung.eth\n * @notice 컨트랙트가 가지고 있는 트랜잭션을 순서대로 실행시킬 수 있음.\n */\nabstract contract Multicall is IMulticall {\n    function multicall(bytes[] calldata callData) external override returns (bytes[] memory returnData) {\n        returnData = new bytes[](callData.length);\n        for (uint256 i = 0; i < callData.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(callData[i]);\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n            if (!success) {\n                // revert called without a message\n                if (result.length < 68) revert();\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            returnData[i] = result;\n        }\n    }\n}\n"
    },
    "contracts/IFactory.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    struct TemplateInfo {\n        address template;\n        address btemplate;\n    }\n\n    event Deployed(address deployed, address owner);\n    event NewTemplate(bytes32 indexed key, address template, address beacon);\n    event UpdatedTemplate(bytes32 indexed key, address template);\n    event DeletedTemplate(bytes32 indexed key);\n    event FeeChanged(uint256 prevFee, uint256 fee);\n    event FeeToChanged(address prevFeeTo, address feeTo);\n\n    function deploy(\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed);\n\n    function deployWithSeed(\n        string memory seed,\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed);\n\n    function compute(\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view returns (address deployable);\n\n    function computeWithSeed(\n        string memory seed,\n        bool isBeacon,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view returns (address deployable);\n\n    function clone(\n        address templateAddr,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed);\n\n    function computeClone(address templateAddr, bytes memory initializationCallData)\n        external\n        view\n        returns (address deployable);\n\n    function getPrice() external view returns (uint256 price);\n\n    function addTemplate(address templateAddr) external;\n\n    function updateTemplate(bytes32 key, address templateAddr) external;\n\n    function removeTemplate(bytes32 key) external;\n\n    function changeFee(uint256 newFee) external;\n\n    function changeFeeTo(address payable newFeeTo) external;\n\n    function collect(address tokenAddr) external;\n}\n"
    },
    "@beandao/contracts/interfaces/IERC173.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-173 Contract Ownership Standard\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\n */\ninterface IERC173 {\n    /**\n     * @dev This emits when ownership of a contract changes.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice Get the address of the owner\n     * @return The address of the owner.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Set the address of the new owner of the contract\n     * @param newOwner The address of the new owner of the contract\n     */\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "@beandao/contracts/library/BeaconMaker.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title BeaconMaker\n * @author yoonsung.eth\n * @notice Beacon Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract BeaconMaker {\n    /**\n     * @param beacon call 했을 경우, 주소가 반환되어야 하는 컨트랙트\n     */\n    constructor(address beacon) payable {\n        // Beacon Address\n        bytes20 targetBytes = bytes20(beacon);\n        // place Beacon Proxy code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\n            mstore(add(clone, 0x6), targetBytes)\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\n            // return Beacon Minimal Proxy code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x3c) // Beacon Minimal Proxy runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/BeaconMakerWithCall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title BeaconMakerWithCall\n * @author yoonsung.eth\n * @notice Beacon Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract BeaconMakerWithCall {\n    /**\n     * @param beacon call 했을 경우, 주소가 반환되어야 함\n     * @param initializationCalldata template로 배포할 때 초기화 할 함수\n     */\n    constructor(address beacon, bytes memory initializationCalldata) payable {\n        (, bytes memory returnData) = beacon.staticcall(\"\");\n        address template = abi.decode(returnData, (address));\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = template.delegatecall(initializationCalldata);\n        if (!success) {\n            // pass along failure message from delegatecall and revert.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Beacon Address\n        bytes20 targetBytes = bytes20(beacon);\n        // place Beacon Proxy code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\n            mstore(add(clone, 0x6), targetBytes)\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\n            // return Beacon Minimal Proxy code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x3c) // Beacon Minimal Proxy runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/MinimalMaker.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title MinimalMaker\n * @author yoonsung.eth\n * @notice Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract MinimalMaker {\n    constructor(address template) payable {\n        // Template Address\n        bytes20 targetBytes = bytes20(template);\n        // place Minimal Proxy eip-1167 code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            // return eip-1167 code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x2d) // eip-1167 runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/MinimalMakerWithCall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title MinimalMakerWithCall\n * @author yoonsung.eth\n * @notice Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract MinimalMakerWithCall {\n    constructor(address template, bytes memory initializationCalldata) payable {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = template.delegatecall(initializationCalldata);\n        if (!success) {\n            // pass along failure message from delegatecall and revert.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Template Address\n        bytes20 targetBytes = bytes20(template);\n        // place Minimal Proxy eip-1167 code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            // return eip-1167 code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x2d) // eip-1167 runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IMulticall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IMulticall {\n    function multicall(bytes[] calldata callData) external returns (bytes[] memory returnData);\n}\n"
    },
    "contracts/mocks/IntegrationMock.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IMulticall.sol\";\nimport \"@beandao/contracts/interfaces/IMint.sol\";\nimport \"@beandao/contracts/interfaces/IERC173.sol\";\nimport \"../IFactory.sol\";\n\ncontract IntegrationMock {\n    IFactory private Factory;\n    bytes32 private TOKEN_KEY;\n\n    event Sample(address deployed);\n\n    constructor(address factoryAddr, bytes32 tokenKey) {\n        Factory = IFactory(factoryAddr);\n        TOKEN_KEY = tokenKey;\n    }\n\n    function deployToken(\n        string calldata name,\n        string calldata symbol,\n        uint256 amount\n    ) external payable returns (address deployed) {\n        bytes[] memory callData = new bytes[](2);\n        callData[0] = abi.encodeWithSelector(IMint.mintTo.selector, msg.sender, amount);\n        callData[1] = abi.encodeWithSelector(IERC173.transferOwnership.selector, msg.sender);\n\n        bytes memory init = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(bytes)\")),\n            abi.encode(name, symbol, uint8(18))\n        );\n        deployed = Factory.deploy{value: msg.value}(false, TOKEN_KEY, init, callData);\n\n        emit Sample(deployed);\n    }\n\n    function calculateAddress(string calldata name, string calldata symbol) external view returns (address calculated) {\n        bytes memory init = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(bytes)\")),\n            abi.encode(name, symbol, uint8(18))\n        );\n        calculated = Factory.compute(false, TOKEN_KEY, init);\n    }\n}\n\ncontract IntegrationSeedMock {\n    IFactory private Factory;\n    bytes32 private TOKEN_KEY;\n    string private seed;\n\n    event Sample(address deployed);\n\n    constructor(\n        string memory seedStr,\n        address factoryAddr,\n        bytes32 tokenKey\n    ) {\n        seed = seedStr;\n        Factory = IFactory(factoryAddr);\n        TOKEN_KEY = tokenKey;\n    }\n\n    function deployToken(\n        string calldata name,\n        string calldata symbol,\n        uint256 amount\n    ) external payable returns (address deployed) {\n        bytes[] memory callData = new bytes[](2);\n        callData[0] = abi.encodeWithSelector(IMint.mintTo.selector, msg.sender, amount);\n        callData[1] = abi.encodeWithSelector(IERC173.transferOwnership.selector, msg.sender);\n\n        bytes memory init = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(bytes)\")),\n            abi.encode(name, symbol, uint8(18))\n        );\n        deployed = Factory.deployWithSeed{value: msg.value}(seed, false, TOKEN_KEY, init, callData);\n\n        emit Sample(deployed);\n    }\n\n    function calculateAddress(string calldata name, string calldata symbol) external view returns (address calculated) {\n        bytes memory init = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(bytes)\")),\n            abi.encode(name, symbol, uint8(18))\n        );\n        calculated = Factory.computeWithSeed(seed, false, TOKEN_KEY, init);\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IMint.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IMint {\n    function mint(uint256 value) external returns (bool);\n\n    function mintTo(address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/utils/VestingEscrow.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IERC20.sol\";\nimport \"@beandao/contracts/interfaces/IERC2612.sol\";\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport {Initializer} from \"@beandao/contracts/library/Initializer.sol\";\nimport {Ownership, IERC173} from \"@beandao/contracts/library/Ownership.sol\";\nimport {Multicall, IMulticall} from \"@beandao/contracts/library/Multicall.sol\";\n\ncontract VestingEscrow is Multicall, Ownership, Initializer, IERC165 {\n    struct LockParam {\n        address recipient;\n        uint128 amount;\n        uint128 startAt;\n        uint128 endAt;\n    }\n\n    struct Vest {\n        uint128 startTime;\n        uint128 endTime;\n        uint128 initialLocked;\n        uint128 totalClaimed;\n    }\n\n    /// @notice 배포할 토큰\n    IERC20 public token;\n    /// @notice 배포가 결정되지 않은 토큰 수량\n    uint256 public unallocatedSupply;\n    /// @notice 배포가 결정된 토큰 수량\n    uint256 public allocatedSupply;\n\n    mapping(address => Vest) public vests;\n\n    event Funded(uint256 amount);\n    event Locked(address indexed recipient, uint256 amount, uint256 startTime);\n    event Claimed(address indexed recipient, uint256 amount);\n\n    function initialize(address tokenAddr, LockParam[] calldata params) external initializer {\n        token = IERC20(tokenAddr);\n        unchecked {\n            for (uint256 i = 0; i < params.length; i++) {\n                _lock(params[i]);\n            }\n        }\n        _transferOwnership(msg.sender);\n    }\n\n    /**\n     * @notice 토큰을 필요한 수량만큼 해당 컨트랙트로 이관하는 함수\n     */\n    function fund(uint256 amount) external onlyOwner {\n        assert(safeTransferFrom(token, msg.sender, address(this), amount));\n        unallocatedSupply += amount;\n        unchecked {\n            if (allocatedSupply > 0) {\n                allocatedSupply -= amount;\n            }\n        }\n        emit Funded(amount);\n    }\n\n    /**\n     * @notice 토큰을 필요한 수량만큼 해당 컨트랙트로 이관하는 함수, 다만 Approve는 서명으로 수행함\n     */\n    function fund(\n        uint256 amount,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external onlyOwner {\n        IERC2612(address(token)).permit(msg.sender, address(this), amount, type(uint256).max, v, r, s);\n        assert(safeTransferFrom(token, msg.sender, address(this), amount));\n        unallocatedSupply += amount;\n        unchecked {\n            if (allocatedSupply > 0) {\n                allocatedSupply -= amount;\n            }\n        }\n        emit Funded(amount);\n    }\n\n    /**\n     * @notice 개별 주소에 베스팅을 지정하는 함수\n     * @param recipient 베스팅이 지정될 주소\n     * @param amount 베스팅 수량\n     * @param startAt 베스팅 시작 시점, Unix time을 이용\n     * @param endAt 베스팅 종료 시점, Unix time을 이용\n     */\n    function lock(\n        address recipient,\n        uint128 amount,\n        uint128 startAt,\n        uint128 endAt\n    ) external onlyOwner {\n        require(recipient != address(0), \"VestingEscrow/Now-Allowed-For-Zero\");\n        require(unallocatedSupply >= amount, \"VestingEscrow/Not-Enough-balance\");\n        require(vests[recipient].startTime == 0, \"VestingEscrow/Already-Registred\");\n        require(startAt >= block.timestamp, \"VestingEscrow/Forwarded-start\");\n        require(endAt > startAt, \"VestingEscrow/Bigger-than-end\");\n        assert(allocatedSupply == 0);\n\n        unchecked {\n            unallocatedSupply -= amount;\n        }\n        vests[recipient] = Vest({startTime: startAt, endTime: endAt, initialLocked: amount, totalClaimed: 0});\n        emit Locked(recipient, amount, startAt);\n    }\n\n    function claim(address recipient) external {\n        uint256 claimable = _vestedOf(recipient) - vests[recipient].totalClaimed;\n        assert(safeTransfer(token, recipient, claimable));\n        unchecked {\n            vests[recipient].totalClaimed += uint128(claimable);\n        }\n        emit Claimed(recipient, claimable);\n    }\n\n    function decreaseLockedOf(address recipient, uint128 amount) external onlyOwner {\n        // 아직 잠겨있는 물량보다, 줄여야 할 물량이 많아야 함\n        require(_lockedOf(recipient) >= amount, \"Not Enough\");\n        this.claim(recipient);\n        unchecked {\n            vests[recipient].initialLocked -= amount;\n        }\n        unallocatedSupply += amount;\n    }\n\n    function claimableOf(address recipient) public view returns (uint256 amount) {\n        amount = _vestedOf(recipient) - vests[recipient].totalClaimed;\n    }\n\n    /// @notice 지정된 시간으로 부터 지금까지 할당된 총 토큰 수량\n    function _vestedOf(address recipient) internal view returns (uint256 amount) {\n        uint256 start = vests[recipient].startTime;\n        uint256 end = vests[recipient].endTime;\n        uint256 locked = vests[recipient].initialLocked;\n        unchecked {\n            uint256 least = ((locked * (block.timestamp - start)) / (end - start));\n            amount = block.timestamp < start ? 0 : least > locked ? locked : least;\n        }\n    }\n\n    /// @notice 지정된 시간으로 부터 지금까지 잠금되어 남아있는 총 토큰 수량\n    function _lockedOf(address recipient) internal view returns (uint256 amount) {\n        uint256 start = vests[recipient].startTime;\n        uint256 end = vests[recipient].endTime;\n        uint256 locked = vests[recipient].initialLocked;\n        unchecked {\n            uint256 least = ((locked * (block.timestamp - start)) / (end - start));\n            amount = block.timestamp < start ? locked : locked - least;\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IERC173).interfaceId ||\n            interfaceID == type(IMulticall).interfaceId;\n    }\n\n    function _lock(LockParam calldata param) internal {\n        allocatedSupply += param.amount;\n        vests[param.recipient] = Vest({\n            startTime: param.startAt,\n            endTime: param.endAt,\n            initialLocked: param.amount,\n            totalClaimed: 0\n        });\n        emit Locked(param.recipient, param.amount, param.startAt);\n    }\n\n    /// @notice Modified from Gnosis\n    /// (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n    function safeTransferFrom(\n        IERC20 tokenAddr,\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool success) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freePointer := mload(0x40)\n            mstore(freePointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freePointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(freePointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(freePointer, 68), amount)\n\n            let callStatus := call(gas(), tokenAddr, 0, freePointer, 100, 0, 0)\n\n            let returnDataSize := returndatasize()\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n\n    function safeTransfer(\n        IERC20 tokenAddr,\n        address to,\n        uint256 amount\n    ) internal returns (bool success) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freePointer := mload(0x40)\n            mstore(freePointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freePointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(freePointer, 36), amount)\n\n            let callStatus := call(gas(), tokenAddr, 0, freePointer, 68, 0, 0)\n\n            let returnDataSize := returndatasize()\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IERC2612.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IERC2612 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@beandao/contracts/library/Initializer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\nabstract contract Initializer {\n    using Address for address;\n\n    bool private _initialized;\n\n    modifier initializer() {\n        require(!_initialized || !address(this).isContract(), \"Initializer/Already Initialized\");\n        _initialized = true;\n        _;\n    }\n}\n"
    },
    "contracts/utils/MerkleDistributor.sol": {
      "content": "/**\n * SPDX-License-Identifier: GPL-3.0-or-later\n * Origin by https://github.com/Uniswap/merkle-distributor\n */\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IERC20.sol\";\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport {Initializer} from \"@beandao/contracts/library/Initializer.sol\";\nimport {Ownership, IERC173} from \"@beandao/contracts/library/Ownership.sol\";\nimport {Multicall, IMulticall} from \"@beandao/contracts/library/Multicall.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\ncontract MerkleDistributor is Multicall, Ownership, Initializer, IERC165 {\n    IERC20 public token;\n    bytes32 public root;\n    mapping(uint256 => uint256) private claimedIndex;\n\n    event Claimed(uint256 index, address account, uint256 amount);\n    event Finalized(address token, bytes32 merkleroot);\n\n    function initialize(address tokenAddr, bytes32 merkleRoot) external initializer {\n        _transferOwnership(msg.sender);\n        token = IERC20(tokenAddr);\n        root = merkleRoot;\n    }\n\n    function isClaimed(uint256 index) public view returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedIndex[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedIndex[claimedWordIndex] = claimedIndex[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    function claim(\n        uint256 index,\n        address account,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(!isClaimed(index), \"MerkleDistributor/Already claimed\");\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, root, node), \"MerkleDistributor/Invalid proof\");\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        token.transfer(account, amount);\n\n        emit Claimed(index, account, amount);\n    }\n\n    /**\n     * 클레임된 비트맵을 유지하면서, 새로운 트리를 등록합니다.\n     */\n    function updateTree(bytes32 merkleRoot) external onlyOwner {\n        require(merkleRoot != bytes32(0), \"MerkleDistributor/Invalid Input\");\n        root = merkleRoot;\n    }\n\n    /**\n     * 배포 종료\n     * 남은 토큰을 오너에게 전송하고, 가스를 낭비하지 않도록 MerkleRoot를 0으로 변경한다.\n     */\n    function finalize() external onlyOwner {\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(msg.sender, balance);\n        root = bytes32(0);\n        emit Finalized(address(token), root);\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IERC173).interfaceId ||\n            interfaceID == type(IMulticall).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "contracts/tokens/StandardERC721.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport {Ownership, IERC173} from \"@beandao/contracts/library/Ownership.sol\";\nimport {Initializer} from \"@beandao/contracts/library/Initializer.sol\";\nimport {ERC721, IERC721, IERC721Enumerable, IERC721Metadata} from \"@beandao/contracts/library/ERC721.sol\";\nimport {Multicall, IMulticall} from \"@beandao/contracts/library/Multicall.sol\";\n\ncontract StandardERC721 is ERC721, Multicall, Ownership, Initializer {\n    string public baseURI;\n\n    function initialize(bytes calldata data) external initializer {\n        (name, symbol, baseURI) = abi.decode(data, (string, string, string));\n        _transferOwnership(msg.sender);\n    }\n\n    function tokenURI(uint256 tokenId) external view override returns (string memory uri) {\n        uri = string(abi.encodePacked(baseURI, tokenId));\n    }\n\n    function mint(uint256 tokenId) external {\n        _mint(msg.sender, tokenId);\n    }\n\n    function mintTo(address to, uint256 tokenId) external {\n        _mint(to, tokenId);\n    }\n\n    function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external {\n        _safeMint(to, tokenId, data);\n    }\n\n    function safeMint(address to, uint256 tokenId) external {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function burn(uint256 tokenId) external {\n        _burn(tokenId);\n    }\n}\n"
    },
    "@beandao/contracts/library/ERC721.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IERC721Enumerable.sol\";\nimport \"../interfaces/IERC721Metadata.sol\";\nimport \"../interfaces/IERC721TokenReceiver.sol\";\nimport \"./Address.sol\";\n\n/**\n * @author yoonsung.eth\n * @notice ERC721의 모든 명세를 만족하는 구현체로써, NFT를 구성하는 외적 정보는 해당 라이브러리를 사용하는 유저가 구현하여 사용할 수 있도록 합니다.\n * @dev NFT는 추가발행될 필요가 있으므로 internal mint 함수를 포함하고 있으며, 이를 이용하는 라이브러리가 Ownership을 적절하게\n */\nabstract contract ERC721 is IERC721Metadata, IERC721Enumerable, IERC721 {\n    using Address for address;\n\n    string public name;\n    string public symbol;\n    address[] private _owners;\n    mapping(uint256 => address) private _approves;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    //------------------------------------------------------------------------------------------------------//\n    // ERC721 Metadata Specification.\n    //------------------------------------------------------------------------------------------------------//\n    // function name() external view virtual returns (string memory name) {}\n\n    // function symbol() external view virtual returns (string memory symbol) {}\n\n    function tokenURI(uint256 tokenId) external view virtual returns (string memory) {}\n\n    //------------------------------------------------------------------------------------------------------//\n    // ERC721 Specification.\n    //------------------------------------------------------------------------------------------------------//\n    function balanceOf(address target) public view virtual returns (uint256 count) {\n        require(target != address(0), \"ERC721: balance query for the zero address\");\n        unchecked {\n            for (uint256 i = 0; i < _owners.length; i++) {\n                if (target == _owners[i]) count++;\n            }\n        }\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual returns (address target) {\n        target = _owners[tokenId];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public payable virtual {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function approve(address to, uint256 tokenId) public payable virtual {\n        address _owner = _owners[tokenId];\n        require(to != _owner, \"ERC721: approval to current owner\");\n        require(msg.sender == _owner || isApprovedForAll(_owner, msg.sender), \"ERC721: Not Owner\");\n        _approves[tokenId] = to;\n        emit Approval(_owner, to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        require(operator != msg.sender, \"ERC721: approve to caller\");\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function getApproved(uint256 tokenId) public view virtual returns (address allowance) {\n        allowance = _approves[tokenId];\n    }\n\n    function isApprovedForAll(address target, address operator) public view virtual returns (bool success) {\n        success = _operatorApprovals[target][operator];\n    }\n\n    //------------------------------------------------------------------------------------------------------//\n    // ERC721 Enumerable Specification.\n    //------------------------------------------------------------------------------------------------------//\n    function totalSupply() public view virtual returns (uint256 total) {\n        address[] memory owners = _owners;\n        unchecked {\n            for (uint256 i = 0; i < owners.length; i++) {\n                if (owners[i] != address(0)) total++;\n            }\n        }\n    }\n\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        require(index < _owners.length, \"ERC721: approved query for nonexistent token\");\n        return index;\n    }\n\n    function tokenOfOwnerByIndex(address target, uint256 index) public view virtual returns (uint256 tokenId) {\n        require(index < balanceOf(target), \"ERC721Enumerable: owner index out of bounds\");\n        uint256 count;\n        unchecked {\n            for (uint256 i; i < _owners.length; i++) {\n                if (target == _owners[i]) {\n                    if (count == index) return i;\n                    else count++;\n                }\n            }\n        }\n        require(false, \"ERC721Enumerable: owner index out of bounds\");\n    }\n\n    //------------------------------------------------------------------------------------------------------//\n    // internal functions\n    //------------------------------------------------------------------------------------------------------//\n    function _nextId() internal view returns (uint256 id) {\n        id = _owners.length;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(_owners[tokenId] == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        _approves[tokenId] = address(0);\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Receive(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _checkOnERC721Receive(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal returns (bool success) {\n        if (to.isContract()) {\n            try IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\n                success = retval == IERC721TokenReceiver.onERC721Received.selector;\n            } catch {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool success) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address _owner = _owners[tokenId];\n        success = (spender == _owner) || (_approves[tokenId] == spender) || isApprovedForAll(_owner, spender);\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool exist) {\n        exist = (tokenId < _owners.length) && (_owners[tokenId] != address(0));\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _owners.push(to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Receive(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address _owner = _owners[tokenId];\n        _approves[tokenId] = address(0);\n        delete _owners[tokenId];\n\n        emit Transfer(_owner, address(0), tokenId);\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IERC721.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory data\n    ) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "@beandao/contracts/interfaces/IERC721Enumerable.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\n/* is ERC721 */\ninterface IERC721Enumerable {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    ///  them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    ///  (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    ///  `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    ///   (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "@beandao/contracts/interfaces/IERC721Metadata.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\n/* is ERC721 */\ninterface IERC721Metadata {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "@beandao/contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes memory _data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/tokens/StandardERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IMint.sol\";\nimport \"@beandao/contracts/interfaces/IBurn.sol\";\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport {Initializer} from \"@beandao/contracts/library/Initializer.sol\";\nimport {Ownership, IERC173} from \"@beandao/contracts/library/Ownership.sol\";\nimport {ERC20, IERC20} from \"@beandao/contracts/library/ERC20.sol\";\nimport {ERC2612, IERC2612} from \"@beandao/contracts/library/ERC2612.sol\";\nimport {Multicall, IMulticall} from \"@beandao/contracts/library/Multicall.sol\";\n\n/**\n * @title StandardERC20\n * @author yoonsung.eth\n * @notice ERC20과 ERC2612를 기본으로, ERC165, ERC173 명세를 구현하고 있습니다.\n */\ncontract StandardERC20 is ERC20, ERC2612, Ownership, Multicall, Initializer, IERC165, IBurn, IMint {\n    /**\n     * @notice ERC20을 초기화 합니다. 토큰의 이름, 심볼, 소수점 정보를 필요로 합니다. 이 함수는 실행될 때 단 한번만 실행됩니다.\n     * 이 함수가 실행될 때 이 함수를 실행한 당사자가 해당 컨트랙트의 소유권을 받게됩니다.\n     * @param data 토큰 이름, 토큰 심볼, 소수점 정보를 abi encode 하여, bytes 형태로 전달하여야 합니다.\n     */\n    function initialize(bytes calldata data) external initializer {\n        (name, symbol, decimals) = abi.decode(data, (string, string, uint8));\n        version = \"1\";\n        balanceOf[address(this)] = type(uint256).max;\n        _initDomainSeparator(name, version);\n        _transferOwnership(msg.sender);\n    }\n\n    function mint(uint256 value) external onlyOwner returns (bool) {\n        totalSupply += value;\n        unchecked {\n            balanceOf[msg.sender] += value;\n        }\n        emit Transfer(address(0), msg.sender, value);\n        return true;\n    }\n\n    function mintTo(address to, uint256 value) external onlyOwner returns (bool) {\n        totalSupply += value;\n        balanceOf[to] += value;\n        emit Transfer(address(0), to, value);\n        return true;\n    }\n\n    function burn(uint256 value) external onlyOwner returns (bool) {\n        balanceOf[msg.sender] -= value;\n        unchecked {\n            totalSupply -= value;\n        }\n        emit Transfer(msg.sender, address(0), value);\n        return true;\n    }\n\n    function burnFrom(address from, uint256 value) external onlyOwner returns (bool) {\n        allowance[from][msg.sender] -= value;\n        balanceOf[from] -= value;\n        unchecked {\n            totalSupply -= value;\n        }\n        emit Transfer(from, address(0), value);\n        return true;\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return\n            type(IERC20).interfaceId == interfaceID ||\n            type(IERC2612).interfaceId == interfaceID ||\n            type(IERC173).interfaceId == interfaceID ||\n            type(IERC165).interfaceId == interfaceID ||\n            type(IMulticall).interfaceId == interfaceID ||\n            type(IBurn).interfaceId == interfaceID ||\n            type(IMint).interfaceId == interfaceID;\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IBurn.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IBurn {\n    function burn(uint256 value) external returns (bool);\n\n    function burnFrom(address from, uint256 value) external returns (bool);\n}\n"
    },
    "@beandao/contracts/library/ERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC20.sol\";\n\nabstract contract ERC20 is IERC20 {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function approve(address spender, uint256 value) external virtual returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external virtual returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external virtual returns (bool) {\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual {\n        balanceOf[from] -= value;\n        unchecked {\n            balanceOf[to] += value;\n        }\n        emit Transfer(from, to, value);\n    }\n\n    function _approve(\n        address _owner,\n        address spender,\n        uint256 value\n    ) internal virtual {\n        require(spender != address(this), \"ERC20/Impossible-Approve-to-Self\");\n        allowance[_owner][spender] = value;\n        emit Approval(_owner, spender, value);\n    }\n}\n"
    },
    "@beandao/contracts/library/ERC2612.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./EIP712.sol\";\nimport \"../interfaces/IERC2612.sol\";\nimport {ERC20} from \"./ERC20.sol\";\n\n/**\n * @title Permit\n * @notice An alternative to approveWithAuthorization, provided for\n * compatibility with the draft EIP2612 proposed by Uniswap.\n * @dev Differences:\n * - Uses sequential nonce, which restricts transaction submission to one at a\n *   time, or else it will revert\n * - Has deadline (= validBefore - 1) but does not have validAfter\n * - Doesn't have a way to change allowance atomically to prevent ERC20 multiple\n *   withdrawal attacks\n */\nabstract contract ERC2612 is ERC20, IERC2612 {\n    bytes32 public immutable PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string public version;\n\n    mapping(address => uint256) public nonces;\n\n    /**\n     * @notice Initialize EIP712 Domain Separator\n     * @param _name        name of contract\n     * @param _version     version of contract\n     */\n    function _initDomainSeparator(string memory _name, string memory _version) internal {\n        version = _version;\n        DOMAIN_SEPARATOR = EIP712.hashDomainSeperator(_name, _version, address(this));\n    }\n\n    /**\n     * @notice Verify a signed approval permit and execute if valid\n     * @param owner     Token owner's address (Authorizer)\n     * @param spender   Spender's address\n     * @param value     Amount of allowance\n     * @param deadline  The time at which this expires (unix time)\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual {\n        require(owner != address(0), \"ERC2612/Invalid-address-0\");\n        require(deadline >= block.timestamp, \"ERC2612/Expired-time\");\n\n        unchecked {\n            bytes32 digest = EIP712.hashMessage(\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            );\n\n            address recovered = ecrecover(digest, v, r, s);\n            require(recovered != address(0) && recovered == owner, \"ERC2612/Invalid-Signature\");\n        }\n\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "@beandao/contracts/library/EIP712.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nlibrary EIP712 {\n    bytes32 internal constant EIP712DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /**\n     * @dev Calculates a EIP712 domain separator.\n     * @param name The EIP712 domain name.\n     * @param version The EIP712 domain version.\n     * @param verifyingContract The EIP712 verifying contract.\n     * @return result EIP712 domain separator.\n     */\n    function hashDomainSeperator(\n        string memory name,\n        string memory version,\n        address verifyingContract\n    ) internal view returns (bytes32 result) {\n        bytes32 typehash = EIP712DOMAIN_TYPEHASH;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let nameHash := keccak256(add(name, 32), mload(name))\n            let versionHash := keccak256(add(version, 32), mload(version))\n            let chainId := chainid()\n\n            let memPtr := mload(64)\n\n            mstore(memPtr, typehash)\n            mstore(add(memPtr, 32), nameHash)\n            mstore(add(memPtr, 64), versionHash)\n            mstore(add(memPtr, 96), chainId)\n            mstore(add(memPtr, 128), verifyingContract)\n\n            result := keccak256(memPtr, 160)\n        }\n    }\n\n    /**\n     * @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\n     * @param domainHash Hash of the domain domain separator data, computed with getDomainHash().\n     * @param hashStruct The EIP712 hash struct.\n     * @return result EIP712 hash applied to the given EIP712 Domain.\n     */\n    function hashMessage(bytes32 domainHash, bytes32 hashStruct) internal pure returns (bytes32 result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000) // EIP191 header\n            mstore(add(memPtr, 2), domainHash) // EIP712 domain hash\n            mstore(add(memPtr, 34), hashStruct) // Hash of struct\n\n            result := keccak256(memPtr, 66)\n        }\n    }\n}\n"
    },
    "contracts/tokens/L2StandardERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport {Initializer} from \"@beandao/contracts/library/Initializer.sol\";\nimport {ERC20, IERC20} from \"@beandao/contracts/library/ERC20.sol\";\nimport {ERC2612, IERC2612} from \"@beandao/contracts/library/ERC2612.sol\";\nimport {Multicall, IMulticall} from \"@beandao/contracts/library/Multicall.sol\";\nimport \"./IL2StandardERC20.sol\";\n\n/**\n * @title L2StandardERC20\n * @author yoonsung.eth\n * @notice ERC20과 ERC2612를 기본으로, ERC165, ERC173 명세를 구현하고 있습니다.\n */\ncontract L2StandardERC20 is ERC20, ERC2612, Multicall, Initializer, IL2StandardERC20, IERC165 {\n    address public immutable l2Bridge = 0x4200000000000000000000000000000000000010;\n    address public l1Token;\n\n    modifier onlyL2Bridge() {\n        require(msg.sender == l2Bridge, \"Only L2 Bridge can mint and burn\");\n        _;\n    }\n\n    /**\n     * @notice ERC20을 초기화 합니다. 토큰의 이름, 심볼, 소수점 정보를 필요로 합니다. 이 함수는 실행될 때 단 한번만 실행됩니다.\n     * 이 함수가 실행될 때 이 함수를 실행한 당사자가 해당 컨트랙트의 소유권을 받게됩니다.\n     * @param data 토큰 이름, 토큰 심볼, 소수점 정보, L2 브릿지, L1 토큰 주소를 abi encode 하여, bytes 형태로 전달하여야 합니다.\n     */\n    function initialize(bytes calldata data) external initializer {\n        (name, symbol, decimals, l1Token) = abi.decode(data, (string, string, uint8, address));\n        version = \"1\";\n        balanceOf[address(this)] = type(uint256).max;\n        balanceOf[l1Token] = type(uint256).max;\n        _initDomainSeparator(name, version);\n    }\n\n    function mint(address to, uint256 value) external onlyL2Bridge {\n        totalSupply += value;\n        unchecked {\n            balanceOf[to] += value;\n        }\n        emit Transfer(address(0), to, value);\n        emit Mint(to, value);\n    }\n\n    function burn(address from, uint256 value) external onlyL2Bridge {\n        balanceOf[from] -= value;\n        unchecked {\n            totalSupply -= value;\n        }\n        emit Transfer(from, address(0), value);\n        emit Burn(from, value);\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return\n            type(IERC20).interfaceId == interfaceID ||\n            type(IERC2612).interfaceId == interfaceID ||\n            type(IERC165).interfaceId == interfaceID ||\n            type(IL2StandardERC20).interfaceId == interfaceID ||\n            type(IMulticall).interfaceId == interfaceID;\n    }\n}\n"
    },
    "contracts/tokens/IL2StandardERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: GPL-3.0-or-later\n * Origin by https://github.com/Uniswap/merkle-distributor\n */\npragma solidity ^0.8.0;\n\ninterface IL2StandardERC20 {\n    function l1Token() external returns (address);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n}\n"
    },
    "contracts/mocks/DummyTwo.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/library/Initializer.sol\";\n\ncontract DummyTwo is Initializer {\n    string public name;\n\n    function initialize(bytes calldata data) external initializer {\n        name = abi.decode(data, (string));\n    }\n\n    function checkName() external view returns (string memory) {\n        return string(abi.encodePacked(\"DummyTwo \", name));\n    }\n}\n"
    },
    "contracts/mocks/DummyOne.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/library/Initializer.sol\";\n\ncontract DummyOne is Initializer {\n    string public name;\n\n    function initialize(bytes calldata data) external initializer {\n        name = abi.decode(data, (string));\n    }\n\n    function checkName() external view returns (string memory) {\n        return string(abi.encodePacked(\"DummyOne \", name));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 42069,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}