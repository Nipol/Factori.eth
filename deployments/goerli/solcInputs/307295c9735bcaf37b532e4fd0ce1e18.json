{
  "language": "Solidity",
  "sources": {
    "contracts/FactoryV1.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport \"@beandao/contracts/interfaces/IERC173.sol\";\nimport \"@beandao/contracts/interfaces/IMulticall.sol\";\nimport \"@beandao/contracts/interfaces/IAllowlist.sol\";\nimport \"@beandao/contracts/library/Ownership.sol\";\nimport \"@beandao/contracts/library/BeaconProxyDeployer.sol\";\nimport \"@beandao/contracts/library/MinimalProxyDeployer.sol\";\nimport \"@beandao/contracts/library/Beacon.sol\";\nimport \"./IFactory.sol\";\n\n/**\n * @title Factory V1\n * @author yoonsung.eth\n * @notice minimal proxy로 배포될 컨트랙트를 template로 추상화 하며 같은 컨트랙트를 쉽게 배포할 수 있도록 함.\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어야 함.\n * 또한 Multicall과 ERC173이 구현되어 컨트랙트의 소유권을 옮길 수 있도록 하여야 함.\n */\ncontract FactoryV1 is Ownership, IFactory {\n    /**\n     * @notice key에 따른 template 반환.\n     */\n    mapping(bytes32 => Template) public templates;\n    /**\n     * @notice 등록된 모든 템플릿에 대한 nonce\n     */\n    mapping(address => uint256) private nonceForTemplate;\n    /**\n     * @notice 템플릿에 연결된 비콘 주소\n     */\n    mapping(address => address) private beaconForTemplate;\n    /**\n     * @notice template가 등록된 숫자.\n     */\n    uint256 public nonce = 1;\n\n    /**\n     * @notice Contract를 무료로 배포할 수 있는 허용된 주소\n     */\n    IAllowlist private immutable allowlist;\n\n    /**\n     * @notice 허용 목록 컨트랙트가 미리 배포되어 주입 되어야 한다.\n     * @param allowContract IAllowlist를 구현한 컨트랙트 주소\n     */\n    constructor(address allowContract) {\n        _transferOwnership(msg.sender);\n        allowlist = IAllowlist(allowContract);\n        nonceForTemplate[address(0)] = type(uint256).max;\n    }\n\n    /**\n     * @notice template id를 통해서 해당 컨트랙트를 배포하는 함수, 여기에는 initialize 함수를 한 번 호출할 수 있도록 call data가 필요함.\n     * @dev deploy에서 기본적으로 오너십을 체크하지는 않기 때문에, 오너십 관리가 필요한 경우 multicall을 통해서 필수적으로 호출해 주어야 함.\n     * @param templateId bytes32 형태의 template id가 필요\n     * @param initializationCallData 템플릿에 적합한 initialize 함수를 호출하는 함수 데이터\n     * @param calls 컨트랙트가 배포된 이후에, 부수적으로 초기화 할 함수들이 있을 때 사용 가능함.\n     */\n    function deploy(\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable override returns (address deployed) {\n        // 배포할 템플릿의 정보\n        Template memory tmp = templates[templateId];\n        // 템플릿을 배포하기 위한 수수료가 적정 수준인지, 템플릿 오너가 호출한 것인지 또는 호출자가 허용된 목록에 있는지 확인.\n        require(\n            tmp.price == msg.value || tmp.owner == msg.sender || allowlist.allowance(msg.sender),\n            \"Factory/Incorrect-amounts\"\n        );\n        // 해당 함수를 호출할 때 수수료가 담긴 경우에 수수료를 컨트랙트 소유자에게 전송하고 기존 수수료에서 일정 비율 만큼 수수료를 상승 시킴\n        if (msg.value > 0) {\n            payable(this.owner()).transfer(msg.value);\n        }\n        deployed = tmp.isBeacon\n            ? BeaconProxyDeployer.deploy(tmp.template, initializationCallData)\n            : MinimalProxyDeployer.deploy(tmp.template, initializationCallData);\n        // 부수적으로 호출할 데이터가 있다면, 배포된 컨트랙트에 추가적인 call을 할 수 있음.\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\n        // 이벤트 호출\n        emit Deployed(deployed, msg.sender);\n    }\n\n    /**\n     * @notice template id와 고정된 Seed를 통해서 해당 컨트랙트를 배포하는 함수,\n     * 여기에는 initialize 함수를 한 번 호출할 수 있도록 call data가 필요함.\n     * @dev deploy에서 기본적으로 오너십을 체크하지는 않기 때문에, 오너십 관리가 필요한 경우 multicall을 통해서 필수적으로 호출해 주어야 함.\n     * @param seed 컨트랙트를 배포할 때 사용할 seed 문자열.\n     * @param templateId bytes32 형태의 template id가 필요\n     * @param initializationCallData 템플릿에 적합한 initialize 함수를 호출하는 함수 데이터\n     * @param calls 컨트랙트가 배포된 이후에 컨트랙트에 호출할 데이터, 부수적으로 초기화 할 함수들이 있을 때 사용 가능함.\n     */\n    function deploy(\n        string memory seed,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable override returns (address deployed) {\n        // 배포할 템플릿의 정보\n        Template memory tmp = templates[templateId];\n        // 템플릿을 배포하기 위한 수수료가 적정 수준인지, 템플릿 오너가 호출한 것인지 또는 호출자가 허용된 목록에 있는지 확인.\n        require(\n            tmp.price == msg.value || tmp.owner == msg.sender || allowlist.allowance(msg.sender),\n            \"Factory/Incorrect-amounts\"\n        );\n        // 해당 함수를 호출할 때 수수료가 담긴 경우에 수수료를 컨트랙트 소유자에게 전송하고 기존 수수료에서 일정 비율 만큼 수수료를 상승 시킴\n        if (msg.value > 0) {\n            payable(this.owner()).transfer(msg.value);\n        }\n        deployed = tmp.isBeacon\n            ? BeaconProxyDeployer.deploy(seed, tmp.template, initializationCallData)\n            : MinimalProxyDeployer.deploy(seed, tmp.template, initializationCallData);\n        // 부수적으로 호출할 데이터가 있다면, 배포된 컨트랙트에 추가적인 call을 할 수 있음.\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\n        // 이벤트 호출\n        emit Deployed(deployed, msg.sender);\n    }\n\n    /**\n     * @notice template id와 초기화 데이터 통해서 컨트랙트를 배포할 주소를 미리 파악하는 함수\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @param templateId bytes32 형태의 template id가 필요\n     * @param initializationCallData 템플릿에 적합한 initialize 함수를 호출하는 함수 데이터\n     */\n    function calculateDeployableAddress(bytes32 templateId, bytes memory initializationCallData)\n        external\n        view\n        override\n        returns (address deployable)\n    {\n        Template memory tmp = templates[templateId];\n        deployable = tmp.isBeacon\n            ? BeaconProxyDeployer.calculateAddress(tmp.template, initializationCallData)\n            : MinimalProxyDeployer.calculateAddress(tmp.template, initializationCallData);\n    }\n\n    /**\n     * @notice template id와 Seed 문자열, 초기화 데이터 통해서 컨트랙트를 배포할 주소를 미리 파악하는 함수\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @param seed 컨트랙트에 사용할 seed 문자열\n     * @param templateId bytes32 형태의 template id가 필요\n     * @param initializationCallData 템플릿에 적합한 initialize 함수를 호출하는 함수 데이터\n     */\n    function calculateDeployableAddress(\n        string memory seed,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view override returns (address deployable) {\n        Template memory tmp = templates[templateId];\n        deployable = tmp.isBeacon\n            ? BeaconProxyDeployer.calculateAddress(seed, tmp.template, initializationCallData)\n            : MinimalProxyDeployer.calculateAddress(seed, tmp.template, initializationCallData);\n    }\n\n    /**\n     * @notice template id에 따라서 컨트랙트를 배포하기 위한 필요 가격을 가져오는 함\n     * @dev 연결된 지갑 주소에 따라 생성될 지갑 주소가 변경되므로, 연결되어 있는 주소를 필수로 확인하여야 합니다.\n     * @param templateId 값을 가져올 템플릿의 아이디\n     * @return price 이더리움으로 구성된 값을 가짐.\n     */\n    function getPrice(bytes32 templateId) external view override returns (uint256 price) {\n        price = templates[templateId].price;\n    }\n\n    /**\n     * @notice 템플릿으로 사용되기 적합한 인터페이스가 구현된 컨트랙트를 템플릿으로 가격과 함께 등록함.\n     * @dev 같은 템플릿이 비콘과, 일반적인 템플릿으로 등록될 수 있습니다. 따라서 선택적으로 사용 가능합니다.\n     * @param templateAddr 템플릿으로 사용될 컨트랙트의 주소\n     * @param ownerAddr 해당 템플릿의 소유주를 지정함. 해당 소유주는 수수료를 지불하지 않음.\n     * @param price 템플릿으로 컨트랙트를 배포할 때 소모될 이더리움의 수량\n     */\n    function addTemplate(\n        address templateAddr,\n        address ownerAddr,\n        uint256 price\n    ) external override onlyOwner {\n        require(nonceForTemplate[templateAddr] == 0, \"Factory/Non-Valid\");\n        bytes32 key = keccak256(abi.encode(templateAddr, nonce));\n        templates[key] = Template({isBeacon: false, template: templateAddr, owner: ownerAddr, price: price});\n        nonceForTemplate[templateAddr] = nonce++;\n        emit NewTemplate(key, templateAddr, price);\n    }\n\n    /**\n     * @notice 템플릿으로 사용되기 적합한 인터페이스를 비콘으로 배포할 수 있도록 합니다.\n     * @param templateAddr 템플릿으로 사용될 컨트랙트의 주소\n     * @param ownerAddr 해당 템플릿의 소유주를 지정함. 해당 소유주는 수수료를 지불하지 않음.\n     * @param price 템플릿으로 컨트랙트를 배포할 때 소모될 이더리움의 수량\n     */\n    function addBeacon(\n        address templateAddr,\n        address ownerAddr,\n        uint256 price\n    ) external override onlyOwner returns (address beaconAddr) {\n        require(beaconForTemplate[templateAddr] == address(0), \"Factory/Non-Valid\");\n        beaconAddr = address(new Beacon(templateAddr));\n        bytes32 key = keccak256(abi.encode(beaconAddr, nonce));\n        templates[key] = Template({isBeacon: true, template: beaconAddr, owner: ownerAddr, price: price});\n        beaconForTemplate[templateAddr] = beaconAddr;\n        emit NewTemplate(key, beaconAddr, price);\n    }\n\n    /**\n     * @notice 등록된 템플릿의 정보를 변경하는 함수, 비콘인 경우에는 템플릿을 업데이트 할 수 있으나 비콘이 아니라면 업데이트 불가능.\n     * @param key 업데이트 될 템플릿의 아이디\n     * @param updateCode 비콘일 경우 템플릿 주소, 템플릿 소유주 주소, 가격을 순서대로 인코딩\n     */\n    function updateTemplate(bytes32 key, bytes memory updateCode) external override onlyOwner {\n        Template memory tmp = templates[key];\n        (address templateAddr, address ownerAddr, uint256 price) = abi.decode(updateCode, (address, address, uint256));\n        require(tmp.isBeacon ? templateAddr != address(0) : templateAddr == address(0), \"Factory/Non-Valid\");\n        tmp.isBeacon ? tmp.template.call(abi.encode(templateAddr)) : (false, new bytes(0));\n        tmp.owner = (ownerAddr != tmp.owner) ? ownerAddr : tmp.owner;\n        tmp.price = price != 0 ? price : tmp.price;\n        templates[key] = tmp;\n        emit UpdatedTemplate(key, tmp.template, tmp.owner, tmp.price);\n    }\n\n    /**\n     * @notice 등록된 템플릿을 삭제하는 함수\n     * @param key 삭제될 템플릿의 아이디\n     */\n    function removeTemplate(bytes32 key) external override onlyOwner {\n        Template memory tmp = templates[key];\n        require(tmp.template != address(0), \"Factory/Non-Exist\");\n        delete templates[key];\n        emit DeletedTemplate(key);\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IERC165.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "@beandao/contracts/interfaces/IERC173.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-173 Contract Ownership Standard\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\n */\ninterface IERC173 {\n    /**\n     * @dev This emits when ownership of a contract changes.\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice Get the address of the owner\n     * @return The address of the owner.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Set the address of the new owner of the contract\n     * @param newOwner The address of the new owner of the contract\n     */\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "@beandao/contracts/interfaces/IMulticall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IMulticall {\n    function multicall(bytes[] calldata callData) external returns (bytes[] memory returnData);\n}\n"
    },
    "@beandao/contracts/interfaces/IAllowlist.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IAllowlist {\n    event Allowed(address indexed addr);\n    event Revoked(address indexed addr);\n\n    function allowance(address) external returns (bool);\n\n    function authorise(address allowAddr) external;\n\n    function revoke(address revokeAddr) external;\n}\n"
    },
    "@beandao/contracts/library/Ownership.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC173.sol\";\n\n/**\n * @title Ownership\n * @author yoonsung.eth\n * @notice 단일 Ownership을 가질 수 있도록 도와주는 추상 컨트랙트\n * @dev constructor 기반 컨트랙트에서는 생성 시점에 owner가 msg.sender로 지정되며,\n *      Proxy로 작동되는 컨트랙트의 경우 `__transferOwnership(address)`를 명시적으로 호출하여 owner를 지정하여야 한다.\n */\nabstract contract Ownership is IERC173 {\n    address public override owner;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownership/Not-Authorized\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    function transferOwnership(address newOwner) external virtual override onlyOwner {\n        require(newOwner != address(0), \"Ownership/Not-Allowed-Zero\");\n        _transferOwnership(newOwner);\n    }\n\n    function resignOwnership() external virtual onlyOwner {\n        delete owner;\n        emit OwnershipTransferred(msg.sender, address(0));\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        address prev = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(prev, newOwner);\n    }\n}\n"
    },
    "@beandao/contracts/library/BeaconProxyDeployer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./BeaconMaker.sol\";\nimport \"./BeaconMakerWithCall.sol\";\n\n/**\n * @title BeaconProxyDeployer\n * @author yoonsung.eth\n * @notice Beacon Minimal Proxy를 배포하는 기능을 가진 라이브러리\n */\nlibrary BeaconProxyDeployer {\n    function deploy(address addr) internal returns (address result) {\n        bytes memory createCode = abi.encodePacked(type(BeaconMaker).creationCode, abi.encode(address(addr)));\n\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(string memory seed, address addr) internal returns (address result) {\n        bytes memory createCode = abi.encodePacked(type(BeaconMaker).creationCode, abi.encode(address(addr)));\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(address addr, bytes memory initializationCalldata) internal returns (address result) {\n        bytes memory createCode = abi.encodePacked(\n            type(BeaconMakerWithCall).creationCode,\n            abi.encode(address(addr), initializationCalldata)\n        );\n\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(\n        string memory seed,\n        address addr,\n        bytes memory initializationCalldata\n    ) internal returns (address result) {\n        bytes memory createCode = abi.encodePacked(\n            type(BeaconMakerWithCall).creationCode,\n            abi.encode(address(addr), initializationCalldata)\n        );\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(address template) internal view returns (address addr) {\n        bytes memory createCode = abi.encodePacked(type(BeaconMaker).creationCode, abi.encode(address(template)));\n\n        (, addr) = getSaltAndTarget(createCode);\n    }\n\n    function calculateAddress(string memory seed, address template) internal view returns (address addr) {\n        bytes memory createCode = abi.encodePacked(type(BeaconMaker).creationCode, abi.encode(address(template)));\n\n        addr = getTargetFromSeed(createCode, seed);\n    }\n\n    function calculateAddress(address template, bytes memory initializationCalldata)\n        internal\n        view\n        returns (address addr)\n    {\n        bytes memory createCode = abi.encodePacked(\n            type(BeaconMakerWithCall).creationCode,\n            abi.encode(address(template), initializationCalldata)\n        );\n\n        (, addr) = getSaltAndTarget(createCode);\n    }\n\n    function calculateAddress(\n        string memory seed,\n        address template,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode = abi.encodePacked(\n            type(BeaconMakerWithCall).creationCode,\n            abi.encode(address(template), initializationCalldata)\n        );\n\n        addr = getTargetFromSeed(createCode, seed);\n    }\n\n    function isBeacon(address beaconAddr, address target) internal view returns (bool result) {\n        bytes20 beaconAddrBytes = bytes20(beaconAddr);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\n            mstore(add(clone, 0x6), beaconAddrBytes)\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\n\n            let other := add(clone, 0x40)\n            extcodecopy(target, other, 0, 0x3c)\n            result := eq(mload(clone), mload(other))\n        }\n    }\n\n    function getSaltAndTarget(bytes memory initCode) internal view returns (bytes32 salt, address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        // set the initial nonce to be provided when constructing the salt.\n        uint256 nonce = 0;\n\n        // declare variable for code size of derived address.\n        bool exist;\n\n        while (true) {\n            // derive `CREATE2` salt using `msg.sender` and nonce.\n            salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n            target = address( // derive the target deployment address.\n                uint160( // downcast to match the address type.\n                    uint256( // cast to uint to truncate upper digits.\n                        keccak256( // compute CREATE2 hash using 4 inputs.\n                            abi.encodePacked( // pack all inputs to the hash together.\n                                bytes1(0xff), // pass in the control character.\n                                address(this), // pass in the address of this contract.\n                                salt, // pass in the salt from above.\n                                initCodeHash // pass in hash of contract creation code.\n                            )\n                        )\n                    )\n                )\n            );\n\n            // determine if a contract is already deployed to the target address.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                exist := gt(extcodesize(target), 0)\n            }\n\n            // exit the loop if no contract is deployed to the target address.\n            if (!exist) {\n                break;\n            }\n\n            // otherwise, increment the nonce and derive a new salt.\n            nonce++;\n        }\n    }\n\n    function getTargetFromSeed(bytes memory initCode, string memory seed) internal view returns (address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        target = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            address(this), // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "@beandao/contracts/library/MinimalProxyDeployer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./MinimalMaker.sol\";\nimport \"./MinimalMakerWithCall.sol\";\n\n/**\n * @title MinimalProxyDeployer\n * @author yoonsung.eth\n * @notice Minimal Proxy를 배포하는 기능을 가진 라이브러리\n */\nlibrary MinimalProxyDeployer {\n    function deploy(address addr) internal returns (address result) {\n        bytes memory createCode = abi.encodePacked(type(MinimalMaker).creationCode, abi.encode(address(addr)));\n\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(string memory seed, address addr) internal returns (address result) {\n        bytes memory createCode = abi.encodePacked(type(MinimalMaker).creationCode, abi.encode(address(addr)));\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(address addr, bytes memory initializationCalldata) internal returns (address result) {\n        bytes memory createCode = abi.encodePacked(\n            type(MinimalMakerWithCall).creationCode,\n            abi.encode(address(addr), initializationCalldata)\n        );\n\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function deploy(\n        string memory seed,\n        address addr,\n        bytes memory initializationCalldata\n    ) internal returns (address result) {\n        bytes memory createCode = abi.encodePacked(\n            type(MinimalMakerWithCall).creationCode,\n            abi.encode(address(addr), initializationCalldata)\n        );\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(address template) internal view returns (address addr) {\n        bytes memory createCode = abi.encodePacked(type(MinimalMaker).creationCode, abi.encode(address(template)));\n        (, addr) = getSaltAndTarget(createCode);\n    }\n\n    function calculateAddress(address template, bytes memory initializationCalldata)\n        internal\n        view\n        returns (address addr)\n    {\n        bytes memory createCode = abi.encodePacked(\n            type(MinimalMakerWithCall).creationCode,\n            abi.encode(address(template), initializationCalldata)\n        );\n\n        (, addr) = getSaltAndTarget(createCode);\n    }\n\n    function calculateAddress(string memory seed, address template) internal view returns (address addr) {\n        bytes memory createCode = abi.encodePacked(type(MinimalMaker).creationCode, abi.encode(address(template)));\n        addr = getTargetFromSeed(createCode, seed);\n    }\n\n    function calculateAddress(\n        string memory seed,\n        address template,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode = abi.encodePacked(\n            type(MinimalMakerWithCall).creationCode,\n            abi.encode(address(template), initializationCalldata)\n        );\n\n        addr = getTargetFromSeed(createCode, seed);\n    }\n\n    function isMinimal(address templateAddr, address target) internal view returns (bool result) {\n        bytes20 templateAddrBytes = bytes20(templateAddr);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), templateAddrBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n            let other := add(clone, 0x40)\n            extcodecopy(target, other, 0, 0x2d)\n            result := eq(mload(clone), mload(other))\n        }\n    }\n\n    function getSaltAndTarget(bytes memory initCode) internal view returns (bytes32 salt, address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        // set the initial nonce to be provided when constructing the salt.\n        uint256 nonce = 0;\n\n        // declare variable for code size of derived address.\n        bool exist;\n\n        while (true) {\n            // derive `CREATE2` salt using `msg.sender` and nonce.\n            salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n            target = address( // derive the target deployment address.\n                uint160( // downcast to match the address type.\n                    uint256( // cast to uint to truncate upper digits.\n                        keccak256( // compute CREATE2 hash using 4 inputs.\n                            abi.encodePacked( // pack all inputs to the hash together.\n                                bytes1(0xff), // pass in the control character.\n                                address(this), // pass in the address of this contract.\n                                salt, // pass in the salt from above.\n                                initCodeHash // pass in hash of contract creation code.\n                            )\n                        )\n                    )\n                )\n            );\n\n            // determine if a contract is already deployed to the target address.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                exist := gt(extcodesize(target), 0)\n            }\n\n            // exit the loop if no contract is deployed to the target address.\n            if (!exist) {\n                break;\n            }\n\n            // otherwise, increment the nonce and derive a new salt.\n            nonce++;\n        }\n    }\n\n    function getTargetFromSeed(bytes memory initCode, string memory seed) internal view returns (address target) {\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(initCode);\n\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\n\n        target = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            address(this), // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "@beandao/contracts/library/Beacon.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title Beacon\n * @author yoonsung.eth\n * @notice Minimal Proxy를 위한 Beacon 컨트랙트이며 구현체 주소를 가지고 있음.\n */\ncontract Beacon {\n    address public _implementation;\n    address public immutable _CONTROLLER;\n\n    constructor(address impl) {\n        _implementation = impl;\n        _CONTROLLER = msg.sender;\n    }\n\n    fallback() external {\n        if (msg.sender != _CONTROLLER) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                mstore(0, sload(0))\n                return(0, 32)\n            }\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                sstore(0, calldataload(0))\n            }\n        }\n    }\n}\n"
    },
    "contracts/IFactory.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    // 어떤 지불 수단으로\n    // 슬롯 맞추기\n    struct Template {\n        // 20\n        address template;\n        // 1\n        bool isBeacon;\n        // 20\n        address owner;\n        // 32\n        uint256 price;\n    }\n\n    function deploy(\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed);\n\n    function calculateDeployableAddress(bytes32 templateId, bytes memory initializationCallData)\n        external\n        view\n        returns (address deployable);\n\n    function deploy(\n        string memory seed,\n        bytes32 templateId,\n        bytes memory initializationCallData,\n        bytes[] memory calls\n    ) external payable returns (address deployed);\n\n    function calculateDeployableAddress(\n        string memory seed,\n        bytes32 templateId,\n        bytes memory initializationCallData\n    ) external view returns (address deployable);\n\n    function getPrice(bytes32 templateId) external view returns (uint256 price);\n\n    function addTemplate(\n        address templateAddr,\n        address ownerAddr,\n        uint256 price\n    ) external;\n\n    function addBeacon(\n        address templateAddr,\n        address ownerAddr,\n        uint256 price\n    ) external returns (address beaconAddr);\n\n    function updateTemplate(bytes32 key, bytes memory updateCode) external;\n\n    function removeTemplate(bytes32 key) external;\n\n    event Deployed(address deployed, address owner);\n    event NewTemplate(bytes32 indexed key, address indexed template, uint256 price);\n    event UpdatedTemplate(bytes32 indexed key, address indexed template, address indexed owner, uint256 price);\n    event DeletedTemplate(bytes32 indexed key);\n}\n"
    },
    "@beandao/contracts/library/BeaconMaker.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title BeaconMaker\n * @author yoonsung.eth\n * @notice Beacon Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract BeaconMaker {\n    /**\n     * @param beacon call 했을 경우, 주소가 반환되어야 하는 컨트랙트\n     */\n    constructor(address beacon) payable {\n        // Beacon Address\n        bytes20 targetBytes = bytes20(beacon);\n        // place Beacon Proxy code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\n            mstore(add(clone, 0x6), targetBytes)\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\n            // return Beacon Minimal Proxy code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x3c) // Beacon Minimal Proxy runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/BeaconMakerWithCall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title BeaconMakerWithCall\n * @author yoonsung.eth\n * @notice Beacon Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract BeaconMakerWithCall {\n    /**\n     * @param beacon call 했을 경우, 주소가 반환되어야 함\n     * @param initializationCalldata template로 배포할 때 초기화 할 함수\n     */\n    constructor(address beacon, bytes memory initializationCalldata) payable {\n        (, bytes memory returnData) = beacon.staticcall(\"\");\n        address template = abi.decode(returnData, (address));\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = template.delegatecall(initializationCalldata);\n        if (!success) {\n            // pass along failure message from delegatecall and revert.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Beacon Address\n        bytes20 targetBytes = bytes20(beacon);\n        // place Beacon Proxy code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\n            mstore(add(clone, 0x6), targetBytes)\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\n            // return Beacon Minimal Proxy code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x3c) // Beacon Minimal Proxy runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/MinimalMaker.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title MinimalMaker\n * @author yoonsung.eth\n * @notice Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract MinimalMaker {\n    constructor(address template) payable {\n        // Template Address\n        bytes20 targetBytes = bytes20(template);\n        // place Minimal Proxy eip-1167 code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            // return eip-1167 code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x2d) // eip-1167 runtime code, length\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/MinimalMakerWithCall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\n/**\n * @title MinimalMakerWithCall\n * @author yoonsung.eth\n * @notice Minimal Proxy를 배포하는 기능을 가진 Maker Dummy\n * @dev template에는 단 한번만 호출 가능한 initialize 함수가 필요하며, 이는 필수적으로 호출되어 과정이 생략되어야 함.\n */\ncontract MinimalMakerWithCall {\n    constructor(address template, bytes memory initializationCalldata) payable {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = template.delegatecall(initializationCalldata);\n        if (!success) {\n            // pass along failure message from delegatecall and revert.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Template Address\n        bytes20 targetBytes = bytes20(template);\n        // place Minimal Proxy eip-1167 code in memory.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            // return eip-1167 code to write it to spawned contract runtime.\n            return(add(0x00, clone), 0x2d) // eip-1167 runtime code, length\n        }\n    }\n}\n"
    },
    "contracts/mocks/IntegrationMock.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IMulticall.sol\";\nimport \"@beandao/contracts/interfaces/IMint.sol\";\nimport \"@beandao/contracts/interfaces/IERC173.sol\";\nimport \"../IFactory.sol\";\n\ncontract IntegrationMock {\n    IFactory private Factory;\n    bytes32 private TOKEN_KEY;\n\n    event Sample(address deployed);\n\n    constructor(address factoryAddr, bytes32 tokenKey) {\n        Factory = IFactory(factoryAddr);\n        TOKEN_KEY = tokenKey;\n    }\n\n    function deployToken(\n        string calldata name,\n        string calldata symbol,\n        uint256 amount\n    ) external payable returns (address deployed) {\n        bytes[] memory callData = new bytes[](2);\n        callData[0] = abi.encodeWithSelector(IMint.mintTo.selector, msg.sender, amount);\n        callData[1] = abi.encodeWithSelector(IERC173.transferOwnership.selector, msg.sender);\n\n        bytes memory init = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(string,string,string,uint8)\")),\n            \"1\",\n            name,\n            symbol,\n            uint8(18)\n        );\n        deployed = Factory.deploy{value: msg.value}(TOKEN_KEY, init, callData);\n\n        emit Sample(deployed);\n    }\n\n    function calculateAddress(string calldata name, string calldata symbol) external view returns (address calculated) {\n        bytes memory init = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(string,string,string,uint8)\")),\n            \"1\",\n            name,\n            symbol,\n            uint8(18)\n        );\n        calculated = Factory.calculateDeployableAddress(TOKEN_KEY, init);\n    }\n}\n\ncontract IntegrationSeedMock {\n    IFactory private Factory;\n    bytes32 private TOKEN_KEY;\n    string private seed;\n\n    event Sample(address deployed);\n\n    constructor(\n        string memory seedStr,\n        address factoryAddr,\n        bytes32 tokenKey\n    ) {\n        seed = seedStr;\n        Factory = IFactory(factoryAddr);\n        TOKEN_KEY = tokenKey;\n    }\n\n    function deployToken(\n        string calldata name,\n        string calldata symbol,\n        uint256 amount\n    ) external payable returns (address deployed) {\n        bytes[] memory callData = new bytes[](2);\n        callData[0] = abi.encodeWithSelector(IMint.mintTo.selector, msg.sender, amount);\n        callData[1] = abi.encodeWithSelector(IERC173.transferOwnership.selector, msg.sender);\n\n        bytes memory init = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(string,string,string,uint8)\")),\n            \"1\",\n            name,\n            symbol,\n            uint8(18)\n        );\n        deployed = Factory.deploy{value: msg.value}(seed, TOKEN_KEY, init, callData);\n\n        emit Sample(deployed);\n    }\n\n    function calculateAddress(string calldata name, string calldata symbol) external view returns (address calculated) {\n        bytes memory init = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(string,string,string,uint8)\")),\n            \"1\",\n            name,\n            symbol,\n            uint8(18)\n        );\n        calculated = Factory.calculateDeployableAddress(seed, TOKEN_KEY, init);\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IMint.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IMint {\n    function mint(uint256 value) external returns (bool);\n\n    function mintTo(address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/templates/StandardToken.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/library/Initializer.sol\";\nimport \"@beandao/contracts/library/Ownership.sol\";\nimport \"@beandao/contracts/library/Multicall.sol\";\nimport \"@beandao/contracts/library/ERC2612.sol\";\nimport \"@beandao/contracts/interfaces/IMulticall.sol\";\nimport \"@beandao/contracts/interfaces/IMint.sol\";\nimport \"@beandao/contracts/interfaces/IBurn.sol\";\nimport \"@beandao/contracts/interfaces/IERC2612.sol\";\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport \"@beandao/contracts/interfaces/IERC173.sol\";\nimport \"@beandao/contracts/interfaces/IERC20.sol\";\n\ncontract StandardToken is\n    IERC20,\n    IERC2612,\n    IBurn,\n    IMint,\n    IERC165,\n    IERC173,\n    IMulticall,\n    ERC2612,\n    Multicall,\n    Ownership,\n    Initializer\n{\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    function initialize(\n        string memory contractVersion,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 tokenDecimals\n    ) external initializer {\n        _transferOwnership(msg.sender);\n        ERC2612._initDomainSeparator(contractVersion, tokenName);\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = tokenDecimals;\n        balanceOf[address(this)] = type(uint256).max;\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        allowance[from][msg.sender] -= value;\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @notice Update allowance with a signed permit\n     * @param _owner       Token owner's address (Authorizer)\n     * @param spender     Spender's address\n     * @param value       Amount of allowance\n     * @param deadline    Expiration time, seconds since the epoch\n     * @param v           v of the signature\n     * @param r           r of the signature\n     * @param s           s of the signature\n     */\n    function permit(\n        address _owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        _permit(_owner, spender, value, deadline, v, r, s);\n    }\n\n    function mint(uint256 value) external override onlyOwner returns (bool) {\n        balanceOf[msg.sender] += value;\n        totalSupply += value;\n        emit Transfer(address(0), msg.sender, value);\n        return true;\n    }\n\n    function mintTo(address to, uint256 value) external override onlyOwner returns (bool) {\n        balanceOf[to] += value;\n        totalSupply += value;\n        emit Transfer(address(0), to, value);\n        return true;\n    }\n\n    function burn(uint256 value) external override onlyOwner returns (bool) {\n        balanceOf[msg.sender] -= value;\n        totalSupply -= value;\n        emit Transfer(msg.sender, address(0), value);\n        return true;\n    }\n\n    function burnFrom(address from, uint256 value) external override onlyOwner returns (bool) {\n        allowance[from][msg.sender] -= value;\n        balanceOf[from] -= value;\n        totalSupply = totalSupply - value;\n        emit Transfer(from, address(0), value);\n        return true;\n    }\n\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return\n            // ERC20\n            interfaceId == type(IERC20).interfaceId ||\n            interfaceId == type(IMint).interfaceId ||\n            interfaceId == type(IBurn).interfaceId ||\n            // ERC2612\n            interfaceId == type(IERC2612).interfaceId ||\n            // ITemplateV1(ERC165, ERC173, IMulticall)\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            interfaceId == type(IMulticall).interfaceId;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    function _approve(\n        address _owner,\n        address spender,\n        uint256 value\n    ) internal override {\n        require(spender != address(this), \"ERC20/Impossible-Approve-to-Self\");\n        allowance[_owner][spender] = value;\n        emit Approval(_owner, spender, value);\n    }\n}\n"
    },
    "@beandao/contracts/library/Initializer.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\nabstract contract Initializer {\n    using Address for address;\n\n    bool private _initialized;\n\n    modifier initializer() {\n        require(!_initialized || !address(this).isContract(), \"Initializer/Already Initialized\");\n        _initialized = true;\n        _;\n    }\n}\n"
    },
    "@beandao/contracts/library/Multicall.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMulticall.sol\";\n\n/**\n * @title Multicall\n * @author yoonsung.eth\n * @notice 컨트랙트가 가지고 있는 트랜잭션을 순서대로 실행시킬 수 있음.\n */\nabstract contract Multicall is IMulticall {\n    function multicall(bytes[] calldata callData) external override returns (bytes[] memory returnData) {\n        returnData = new bytes[](callData.length);\n        for (uint256 i = 0; i < callData.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(callData[i]);\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n            if (!success) {\n                // revert called without a message\n                if (result.length < 68) revert();\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            returnData[i] = result;\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/ERC2612.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"./EIP712.sol\";\nimport {ERC20} from \"./ERC20.sol\";\n\n/**\n * @title Permit\n * @notice An alternative to approveWithAuthorization, provided for\n * compatibility with the draft EIP2612 proposed by Uniswap.\n * @dev Differences:\n * - Uses sequential nonce, which restricts transaction submission to one at a\n *   time, or else it will revert\n * - Has deadline (= validBefore - 1) but does not have validAfter\n * - Doesn't have a way to change allowance atomically to prevent ERC20 multiple\n *   withdrawal attacks\n */\nabstract contract ERC2612 is ERC20 {\n    bytes32 public immutable PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string public version;\n\n    mapping(address => uint256) public nonces;\n\n    /**\n     * @notice Initialize EIP712 Domain Separator\n     * @param _name        name of contract\n     * @param _version     version of contract\n     */\n    function _initDomainSeparator(string memory _name, string memory _version) internal {\n        version = _version;\n        DOMAIN_SEPARATOR = EIP712.hashDomainSeperator(_name, _version, address(this));\n    }\n\n    /**\n     * @notice Verify a signed approval permit and execute if valid\n     * @param owner     Token owner's address (Authorizer)\n     * @param spender   Spender's address\n     * @param value     Amount of allowance\n     * @param deadline  The time at which this expires (unix time)\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     */\n    function _permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal virtual {\n        require(owner != address(0), \"ERC2612/Invalid-address-0\");\n        require(deadline >= block.timestamp, \"ERC2612/Expired-time\");\n\n        bytes32 digest = EIP712.hashMessage(\n            DOMAIN_SEPARATOR,\n            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n        );\n        address recovered = ecrecover(digest, v, r, s);\n        require(recovered != address(0) && recovered == owner, \"ERC2612/Invalid-Signature\");\n\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "@beandao/contracts/interfaces/IBurn.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IBurn {\n    function burn(uint256 value) external returns (bool);\n\n    function burnFrom(address from, uint256 value) external returns (bool);\n}\n"
    },
    "@beandao/contracts/interfaces/IERC2612.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IERC2612 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@beandao/contracts/interfaces/IERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function balanceOf(address target) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n"
    },
    "@beandao/contracts/library/Address.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n    function isContract(address target) internal view returns (bool result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := gt(extcodesize(target), 0)\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/EIP712.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nlibrary EIP712 {\n    bytes32 internal constant EIP712DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /**\n     * @dev Calculates a EIP712 domain separator.\n     * @param name The EIP712 domain name.\n     * @param version The EIP712 domain version.\n     * @param verifyingContract The EIP712 verifying contract.\n     * @return result EIP712 domain separator.\n     */\n    function hashDomainSeperator(\n        string memory name,\n        string memory version,\n        address verifyingContract\n    ) internal view returns (bytes32 result) {\n        bytes32 typehash = EIP712DOMAIN_TYPEHASH;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let nameHash := keccak256(add(name, 32), mload(name))\n            let versionHash := keccak256(add(version, 32), mload(version))\n            let chainId := chainid()\n\n            let memPtr := mload(64)\n\n            mstore(memPtr, typehash)\n            mstore(add(memPtr, 32), nameHash)\n            mstore(add(memPtr, 64), versionHash)\n            mstore(add(memPtr, 96), chainId)\n            mstore(add(memPtr, 128), verifyingContract)\n\n            result := keccak256(memPtr, 160)\n        }\n    }\n\n    /**\n     * @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\n     * @param domainHash Hash of the domain domain separator data, computed with getDomainHash().\n     * @param hashStruct The EIP712 hash struct.\n     * @return result EIP712 hash applied to the given EIP712 Domain.\n     */\n    function hashMessage(bytes32 domainHash, bytes32 hashStruct) internal pure returns (bytes32 result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let memPtr := mload(64)\n\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000) // EIP191 header\n            mstore(add(memPtr, 2), domainHash) // EIP712 domain hash\n            mstore(add(memPtr, 34), hashStruct) // Hash of struct\n\n            result := keccak256(memPtr, 66)\n        }\n    }\n}\n"
    },
    "@beandao/contracts/library/ERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nabstract contract ERC20 {\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal virtual;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual;\n}\n"
    },
    "contracts/templates/VestingEscrow.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/library/Initializer.sol\";\nimport \"@beandao/contracts/library/Ownership.sol\";\nimport \"@beandao/contracts/library/Multicall.sol\";\nimport \"@beandao/contracts/interfaces/IERC20.sol\";\n\ncontract VestingEscrow is Multicall, Ownership, Initializer {\n    IERC20 public token;\n    uint256 public unallocatedSupply;\n    uint256 public allocatedSupply;\n\n    mapping(address => uint256) public startTime;\n    mapping(address => uint256) public endTime;\n    mapping(address => uint256) public initialLocked;\n    mapping(address => uint256) public totalClaimed;\n\n    event Funded(address indexed recipient, uint256 amount);\n    event Vested(address indexed recipient, uint256 amount, uint256 endTime);\n    event Claimed(address indexed recipient, uint256 amount);\n\n    function initialize(address tokenAddr) external initializer {\n        _transferOwnership(msg.sender);\n        token = IERC20(tokenAddr);\n    }\n\n    function fund(uint256 amount) external onlyOwner {\n        require(token.transferFrom(msg.sender, address(this), amount), \"VestingEscrow/Approve\");\n        unallocatedSupply += amount;\n    }\n\n    function fund(\n        address recipient,\n        uint256 amount,\n        uint256 startAt,\n        uint256 endAt\n    ) external onlyOwner {\n        require(startTime[recipient] == 0, \"VestingEscrow/Already-Registred\");\n        require(startAt >= block.timestamp, \"\");\n        require(endAt > startAt, \"\");\n        require(recipient != address(0), \"VestingEscrow/Now-Allowed-For-Zero\");\n\n        assert(unallocatedSupply <= amount);\n\n        initialLocked[recipient] += amount;\n        startTime[recipient] = startAt;\n        endTime[recipient] = endAt;\n        allocatedSupply += amount;\n        unallocatedSupply -= amount;\n\n        //     _total_amount: uint256 = 0\n        //     for i in range(100):\n        //         amount: uint256 = _amounts[i]\n        //         recipient: address = _recipients[i]\n        //         if recipient == ZERO_ADDRESS:\n        //             break\n        //         _total_amount += amount\n        //         self.initial_locked[recipient] += amount\n        //         log Fund(recipient, amount)\n\n        //     self.initial_locked_supply += _total_amount\n        //     self.unallocated_supply -= _total_amount\n    }\n}\n\n// # @version 0.2.4\n// \"\"\"\n// @title Vesting Escrow\n// @author Curve Finance\n// @license MIT\n// @notice Vests `ERC20CRV` tokens for multiple addresses over multiple vesting periods\n// \"\"\"\n\n// from vyper.interfaces import ERC20\n\n// event Fund:\n//     recipient: indexed(address)\n//     amount: uint256\n\n// event Claim:\n//     recipient: indexed(address)\n//     claimed: uint256\n\n// event ToggleDisable:\n//     recipient: address\n//     disabled: bool\n\n// event CommitOwnership:\n//     admin: address\n\n// event ApplyOwnership:\n//     admin: address\n\n// token: public(address)\n// start_time: public(uint256)\n// end_time: public(uint256)\n// initial_locked: public(HashMap[address, uint256])\n// total_claimed: public(HashMap[address, uint256])\n\n// initial_locked_supply: public(uint256)\n// unallocated_supply: public(uint256)\n\n// can_disable: public(bool)\n// disabled_at: public(HashMap[address, uint256])\n\n// admin: public(address)\n// future_admin: public(address)\n\n// fund_admins_enabled: public(bool)\n// fund_admins: public(HashMap[address, bool])\n\n// @external\n// def __init__(\n//     _token: address,\n//     _start_time: uint256,\n//     _end_time: uint256,\n//     _can_disable: bool,\n//     _fund_admins: address[4]\n// ):\n//     \"\"\"\n//     @param _token Address of the ERC20 token being distributed\n//     @param _start_time Timestamp at which the distribution starts. Should be in\n//         the future, so that we have enough time to VoteLock everyone\n//     @param _end_time Time until everything should be vested\n//     @param _can_disable Whether admin can disable accounts in this deployment\n//     @param _fund_admins Temporary admin accounts used only for funding\n//     \"\"\"\n//     assert _start_time >= block.timestamp\n//     assert _end_time > _start_time\n\n//     self.token = _token\n//     self.admin = msg.sender\n//     self.start_time = _start_time\n//     self.end_time = _end_time\n//     self.can_disable = _can_disable\n\n//     _fund_admins_enabled: bool = False\n//     for addr in _fund_admins:\n//         if addr != ZERO_ADDRESS:\n//             self.fund_admins[addr] = True\n//             if not _fund_admins_enabled:\n//                 _fund_admins_enabled = True\n//                 self.fund_admins_enabled = True\n\n// @external\n// def add_tokens(_amount: uint256):\n//     \"\"\"\n//     @notice Transfer vestable tokens into the contract\n//     @dev Handled separate from `fund` to reduce transaction count when using funding admins\n//     @param _amount Number of tokens to transfer\n//     \"\"\"\n//     assert msg.sender == self.admin  # dev: admin only\n//     assert ERC20(self.token).transferFrom(msg.sender, self, _amount)  # dev: transfer failed\n//     self.unallocated_supply += _amount\n\n// @external\n// @nonreentrant('lock')\n// def fund(_recipients: address[100], _amounts: uint256[100]):\n//     \"\"\"\n//     @notice Vest tokens for multiple recipients\n//     @param _recipients List of addresses to fund\n//     @param _amounts Amount of vested tokens for each address\n//     \"\"\"\n//     if msg.sender != self.admin:\n//         assert self.fund_admins[msg.sender]  # dev: admin only\n//         assert self.fund_admins_enabled  # dev: fund admins disabled\n\n//     _total_amount: uint256 = 0\n//     for i in range(100):\n//         amount: uint256 = _amounts[i]\n//         recipient: address = _recipients[i]\n//         if recipient == ZERO_ADDRESS:\n//             break\n//         _total_amount += amount\n//         self.initial_locked[recipient] += amount\n//         log Fund(recipient, amount)\n\n//     self.initial_locked_supply += _total_amount\n//     self.unallocated_supply -= _total_amount\n\n// @external\n// def toggle_disable(_recipient: address):\n//     \"\"\"\n//     @notice Disable or re-enable a vested address's ability to claim tokens\n//     @dev When disabled, the address is only unable to claim tokens which are still\n//          locked at the time of this call. It is not possible to block the claim\n//          of tokens which have already vested.\n//     @param _recipient Address to disable or enable\n//     \"\"\"\n//     assert msg.sender == self.admin  # dev: admin only\n//     assert self.can_disable, \"Cannot disable\"\n\n//     is_disabled: bool = self.disabled_at[_recipient] == 0\n//     if is_disabled:\n//         self.disabled_at[_recipient] = block.timestamp\n//     else:\n//         self.disabled_at[_recipient] = 0\n\n//     log ToggleDisable(_recipient, is_disabled)\n\n// @external\n// def disable_can_disable():\n//     \"\"\"\n//     @notice Disable the ability to call `toggle_disable`\n//     \"\"\"\n//     assert msg.sender == self.admin  # dev: admin only\n//     self.can_disable = False\n\n// @external\n// def disable_fund_admins():\n//     \"\"\"\n//     @notice Disable the funding admin accounts\n//     \"\"\"\n//     assert msg.sender == self.admin  # dev: admin only\n//     self.fund_admins_enabled = False\n\n// @internal\n// @view\n// def _total_vested_of(_recipient: address, _time: uint256 = block.timestamp) -> uint256:\n//     start: uint256 = self.start_time\n//     end: uint256 = self.end_time\n//     locked: uint256 = self.initial_locked[_recipient]\n//     if _time < start:\n//         return 0\n//     return min(locked * (_time - start) / (end - start), locked)\n\n// @internal\n// @view\n// def _total_vested() -> uint256:\n//     start: uint256 = self.start_time\n//     end: uint256 = self.end_time\n//     locked: uint256 = self.initial_locked_supply\n//     if block.timestamp < start:\n//         return 0\n//     return min(locked * (block.timestamp - start) / (end - start), locked)\n\n// @external\n// @view\n// def vestedSupply() -> uint256:\n//     \"\"\"\n//     @notice Get the total number of tokens which have vested, that are held\n//             by this contract\n//     \"\"\"\n//     return self._total_vested()\n\n// @external\n// @view\n// def lockedSupply() -> uint256:\n//     \"\"\"\n//     @notice Get the total number of tokens which are still locked\n//             (have not yet vested)\n//     \"\"\"\n//     return self.initial_locked_supply - self._total_vested()\n\n// @external\n// @view\n// def vestedOf(_recipient: address) -> uint256:\n//     \"\"\"\n//     @notice Get the number of tokens which have vested for a given address\n//     @param _recipient address to check\n//     \"\"\"\n//     return self._total_vested_of(_recipient)\n\n// @external\n// @view\n// def balanceOf(_recipient: address) -> uint256:\n//     \"\"\"\n//     @notice Get the number of unclaimed, vested tokens for a given address\n//     @param _recipient address to check\n//     \"\"\"\n//     return self._total_vested_of(_recipient) - self.total_claimed[_recipient]\n\n// @external\n// @view\n// def lockedOf(_recipient: address) -> uint256:\n//     \"\"\"\n//     @notice Get the number of locked tokens for a given address\n//     @param _recipient address to check\n//     \"\"\"\n//     return self.initial_locked[_recipient] - self._total_vested_of(_recipient)\n\n// @external\n// @nonreentrant('lock')\n// def claim(addr: address = msg.sender):\n//     \"\"\"\n//     @notice Claim tokens which have vested\n//     @param addr Address to claim tokens for\n//     \"\"\"\n//     t: uint256 = self.disabled_at[addr]\n//     if t == 0:\n//         t = block.timestamp\n//     claimable: uint256 = self._total_vested_of(addr, t) - self.total_claimed[addr]\n//     self.total_claimed[addr] += claimable\n//     assert ERC20(self.token).transfer(addr, claimable)\n\n//     log Claim(addr, claimable)\n\n// @external\n// def commit_transfer_ownership(addr: address) -> bool:\n//     \"\"\"\n//     @notice Transfer ownership of GaugeController to `addr`\n//     @param addr Address to have ownership transferred to\n//     \"\"\"\n//     assert msg.sender == self.admin  # dev: admin only\n//     self.future_admin = addr\n//     log CommitOwnership(addr)\n\n//     return True\n\n// @external\n// def apply_transfer_ownership() -> bool:\n//     \"\"\"\n//     @notice Apply pending ownership transfer\n//     \"\"\"\n//     assert msg.sender == self.admin  # dev: admin only\n//     _admin: address = self.future_admin\n//     assert _admin != ZERO_ADDRESS  # dev: admin not set\n//     self.admin = _admin\n//     log ApplyOwnership(_admin)\n\n//     return True\n"
    },
    "contracts/templates/StandardNFT.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/library/Initializer.sol\";\nimport \"@beandao/contracts/library/Ownership.sol\";\nimport \"@beandao/contracts/library/Multicall.sol\";\nimport \"./ITemplateV1.sol\";\nimport \"@beandao/contracts/interfaces/IERC721Metadata.sol\";\nimport \"@beandao/contracts/interfaces/IERC721.sol\";\n\n// mint와 burn 필요.\n// mint는 오너 서명에 의해 생성될 수 있는 기능 필요.\ncontract StandardNFT is IERC721, IERC721Metadata, ITemplateV1, Multicall, Ownership, Initializer {\n    string public override name;\n    string public override symbol;\n    mapping(uint256 => string) public override tokenURI;\n    mapping(address => uint256) public override balanceOf;\n    mapping(uint256 => address) public override ownerOf;\n\n    function initialize(string memory nameStr, string memory symbolStr) external initializer {\n        _transferOwnership(msg.sender);\n        name = nameStr;\n        symbol = symbolStr;\n    }\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory data\n    ) external payable override {}\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable override {}\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable override {}\n\n    function approve(address _approved, uint256 _tokenId) external payable override {}\n\n    function setApprovalForAll(address _operator, bool _approved) external override {}\n\n    function getApproved(uint256 _tokenId) external view override returns (address) {}\n\n    function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {}\n\n    function supportsInterface(bytes4 interfaceID) external pure override returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId || // ERC165\n            interfaceID == type(IERC173).interfaceId || // ERC173\n            interfaceID == type(IERC721Metadata).interfaceId || // ERC721Metadata\n            interfaceID == type(IERC721).interfaceId || // ERC721\n            interfaceID == type(ITemplateV1).interfaceId; // ITemplateV1\n    }\n}\n"
    },
    "contracts/templates/ITemplateV1.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport \"@beandao/contracts/interfaces/IERC173.sol\";\nimport \"@beandao/contracts/interfaces/IMulticall.sol\";\n\ninterface ITemplateV1 is IERC165, IERC173, IMulticall {}\n"
    },
    "@beandao/contracts/interfaces/IERC721Metadata.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\n/* is ERC721 */\ninterface IERC721Metadata {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "@beandao/contracts/interfaces/IERC721.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\npragma solidity ^0.8.0;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory data\n    ) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "contracts/templates/MerkleDistributor.sol": {
      "content": "/**\n * SPDX-License-Identifier: GPL-3.0-or-later\n * Origin by https://github.com/Uniswap/merkle-distributor\n */\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/interfaces/IERC20.sol\";\nimport \"@beandao/contracts/interfaces/IERC165.sol\";\nimport \"@beandao/contracts/interfaces/IERC173.sol\";\nimport \"@beandao/contracts/interfaces/IMulticall.sol\";\nimport \"@beandao/contracts/library/Initializer.sol\";\nimport \"@beandao/contracts/library/Ownership.sol\";\nimport \"@beandao/contracts/library/Multicall.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./ITemplateV1.sol\";\n\ncontract MerkleDistributor is ITemplateV1, Multicall, Ownership, Initializer {\n    IERC20 public token;\n    bytes32 public root;\n    mapping(uint256 => uint256) private claimedIndex;\n\n    event Claimed(uint256 index, address account, uint256 amount);\n    event Finalized(address token, bytes32 merkleroot);\n\n    function initialize(address tokenAddr, bytes32 merkleRoot) external initializer {\n        _transferOwnership(msg.sender);\n        token = IERC20(tokenAddr);\n        root = merkleRoot;\n    }\n\n    function isClaimed(uint256 index) public view returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedIndex[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedIndex[claimedWordIndex] = claimedIndex[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    function claim(\n        uint256 index,\n        address account,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(!isClaimed(index), \"MerkleDistributor/Already claimed\");\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, root, node), \"MerkleDistributor/Invalid proof\");\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        token.transfer(account, amount);\n\n        emit Claimed(index, account, amount);\n    }\n\n    /**\n     * 클레임된 비트맵을 유지하면서, 새로운 트리를 등록합니다.\n     */\n    function updateTree(bytes32 merkleRoot) external onlyOwner {\n        require(merkleRoot != bytes32(0), \"MerkleDistributor/Invalid Input\");\n        root = merkleRoot;\n    }\n\n    /**\n     * 배포 종료\n     * 남은 토큰을 오너에게 전송하고, 가스를 낭비하지 않도록 MerkleRoot를 0으로 변경한다.\n     */\n    function finalize() external onlyOwner {\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(msg.sender, balance);\n        root = bytes32(0);\n        emit Finalized(address(token), root);\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure override returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IERC173).interfaceId ||\n            interfaceID == type(IMulticall).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/templates/Dutchauction.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/library/Multicall.sol\";\nimport \"@beandao/contracts/library/Ownership.sol\";\nimport \"@beandao/contracts/library/Initializer.sol\";\nimport \"./ITemplateV1.sol\";\n\ncontract DutchAuction is ITemplateV1, Multicall, Ownership, Initializer {\n    function supportsInterface(bytes4 interfaceID) external pure override returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId || // ERC165\n            interfaceID == type(IERC173).interfaceId || // ERC173\n            interfaceID == type(ITemplateV1).interfaceId; // ITemplateV1\n    }\n}\n"
    },
    "contracts/mocks/DummyTwo.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/library/Initializer.sol\";\n\ncontract DummyTwo is Initializer {\n    string public name;\n\n    function initialize(string memory _name) external initializer {\n        name = _name;\n    }\n\n    function checkName() external view returns (string memory) {\n        return string(abi.encodePacked(\"DummyTwo \", name));\n    }\n}\n"
    },
    "contracts/mocks/DummyOne.sol": {
      "content": "/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n */\n\npragma solidity ^0.8.0;\n\nimport \"@beandao/contracts/library/Initializer.sol\";\n\ncontract DummyOne is Initializer {\n    string public name;\n\n    function initialize(string memory _name) external initializer {\n        name = _name;\n    }\n\n    function checkName() external view returns (string memory) {\n        return string(abi.encodePacked(\"DummyOne \", name));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999999,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}